/* tslint:disable */
/* eslint-disable */
/**
 * Mednet EDC API
 * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
 *
 * The version of the OpenAPI document: 1.3.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Coding
 */
export interface Coding {
    /**
     * Unique study key
     * @type {string}
     * @memberof Coding
     */
    'studyKey'?: string;
    /**
     * Name of the site associated with the coded data
     * @type {string}
     * @memberof Coding
     */
    'siteName'?: string;
    /**
     * Site ID associated with the coded data
     * @type {number}
     * @memberof Coding
     */
    'siteId'?: number;
    /**
     * Subject ID associated with the coded data
     * @type {number}
     * @memberof Coding
     */
    'subjectId'?: number;
    /**
     * Subject key (display ID) associated with the coded data
     * @type {string}
     * @memberof Coding
     */
    'subjectKey'?: string;
    /**
     * Form ID where the coded data originates
     * @type {number}
     * @memberof Coding
     */
    'formId'?: number;
    /**
     * Name of the form where the coded data originates
     * @type {string}
     * @memberof Coding
     */
    'formName'?: string;
    /**
     * Form key where the coded data originates
     * @type {string}
     * @memberof Coding
     */
    'formKey'?: string;
    /**
     * Revision number of the coding entry
     * @type {number}
     * @memberof Coding
     */
    'revision'?: number;
    /**
     * Record ID associated with the coded data
     * @type {number}
     * @memberof Coding
     */
    'recordId'?: number;
    /**
     * Variable name (field) that was coded
     * @type {string}
     * @memberof Coding
     */
    'variable'?: string;
    /**
     * Original value entered that required coding
     * @type {string}
     * @memberof Coding
     */
    'value'?: string;
    /**
     * Mednet coding ID
     * @type {number}
     * @memberof Coding
     */
    'codingId'?: number;
    /**
     * Standardized code assigned (e.g., dictionary term)
     * @type {string}
     * @memberof Coding
     */
    'code'?: string;
    /**
     * Name of the user who performed the coding
     * @type {string}
     * @memberof Coding
     */
    'codedBy'?: string;
    /**
     * Reason for coding or any notes on changes
     * @type {string}
     * @memberof Coding
     */
    'reason'?: string;
    /**
     * Name of the dictionary used (e.g., MedDRA)
     * @type {string}
     * @memberof Coding
     */
    'dictionaryName'?: string;
    /**
     * Version of the dictionary used
     * @type {string}
     * @memberof Coding
     */
    'dictionaryVersion'?: string;
    /**
     * Date when the coding was performed
     * @type {string}
     * @memberof Coding
     */
    'dateCoded'?: string;
}
/**
 * 
 * @export
 * @interface CodingList
 */
export interface CodingList {
    /**
     * 
     * @type {Metadata}
     * @memberof CodingList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof CodingList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Coding>}
     * @memberof CodingList
     */
    'data'?: Array<Coding>;
}
/**
 * 
 * @export
 * @interface ComponentsSchemasIntervalFormsItem
 */
export interface ComponentsSchemasIntervalFormsItem {
    /**
     * Form ID scheduled in the interval
     * @type {number}
     * @memberof ComponentsSchemasIntervalFormsItem
     */
    'formId'?: number;
    /**
     * Form key scheduled in the interval
     * @type {string}
     * @memberof ComponentsSchemasIntervalFormsItem
     */
    'formKey'?: string;
    /**
     * Form name scheduled in the interval
     * @type {string}
     * @memberof ComponentsSchemasIntervalFormsItem
     */
    'formName'?: string;
}
/**
 * Error details if an error occurred
 * @export
 * @interface ComponentsSchemasMetadataError
 */
export interface ComponentsSchemasMetadataError {
    [key: string]: any;

    /**
     * Error message describing the issue
     * @type {string}
     * @memberof ComponentsSchemasMetadataError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ComponentsSchemasRecordCreateRequestItem
 */
export interface ComponentsSchemasRecordCreateRequestItem {
    /**
     * Form key identifying the eCRF to create or update
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'formKey': string;
    /**
     * Form ID identifying the eCRF to create or update (alternative to formKey)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'formId'?: number;
    /**
     * Name of the site where the record should be created (for new subject registration)
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'siteName'?: string;
    /**
     * Site ID for the record (alternative to siteName)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'siteId'?: number;
    /**
     * Subject identifier (display ID) for which to create or update the record
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'subjectKey'?: string;
    /**
     * Subject ID for which to create or update the record (alternative to subjectKey)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'subjectId'?: number;
    /**
     * Subject OID for which to create or update the record (alternative to subjectKey)
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'subjectOid'?: string;
    /**
     * Name of the interval (visit) for a scheduled record update
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'intervalName'?: string;
    /**
     * Interval ID for a scheduled record update (alternative to intervalName)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'intervalId'?: number;
    /**
     * Record ID for updating an existing unscheduled record (if applicable)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'recordId'?: number;
    /**
     * Record OID for updating an existing unscheduled record (if applicable)
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'recordOid'?: string;
    /**
     * Key-value pairs of field names and values for the record data
     * @type {{ [key: string]: any; }}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    'data': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Form
 */
export interface Form {
    /**
     * Unique study key
     * @type {string}
     * @memberof Form
     */
    'studyKey'?: string;
    /**
     * Mednet Form ID
     * @type {number}
     * @memberof Form
     */
    'formId'?: number;
    /**
     * User-defined form key
     * @type {string}
     * @memberof Form
     */
    'formKey'?: string;
    /**
     * Name of the form (eCRF)
     * @type {string}
     * @memberof Form
     */
    'formName'?: string;
    /**
     * Type of the form (e.g., Subject or Site)
     * @type {string}
     * @memberof Form
     */
    'formType'?: string;
    /**
     * Number of modifications (revisions) of the form metadata
     * @type {number}
     * @memberof Form
     */
    'revision'?: number;
    /**
     * Whether the form has an embedded log
     * @type {boolean}
     * @memberof Form
     */
    'embeddedLog'?: boolean;
    /**
     * Whether the form enforces record ownership
     * @type {boolean}
     * @memberof Form
     */
    'enforceOwnership'?: boolean;
    /**
     * Whether the form requires a user agreement
     * @type {boolean}
     * @memberof Form
     */
    'userAgreement'?: boolean;
    /**
     * Whether the form is marked as a subject record report
     * @type {boolean}
     * @memberof Form
     */
    'subjectRecordReport'?: boolean;
    /**
     * Whether the form is included in unscheduled visits
     * @type {boolean}
     * @memberof Form
     */
    'unscheduledVisit'?: boolean;
    /**
     * Whether the form is included in Other Forms category
     * @type {boolean}
     * @memberof Form
     */
    'otherForms'?: boolean;
    /**
     * Whether the form is an ePRO (electronic patient reported outcome) form
     * @type {boolean}
     * @memberof Form
     */
    'eproForm'?: boolean;
    /**
     * Whether the form allows copying of data
     * @type {boolean}
     * @memberof Form
     */
    'allowCopy'?: boolean;
    /**
     * Whether the form is soft-deleted (disabled)
     * @type {boolean}
     * @memberof Form
     */
    'disabled'?: boolean;
    /**
     * Date when this form was created
     * @type {string}
     * @memberof Form
     */
    'dateCreated'?: string;
    /**
     * Date when this form was last modified
     * @type {string}
     * @memberof Form
     */
    'dateModified'?: string;
}
/**
 * 
 * @export
 * @interface FormList
 */
export interface FormList {
    /**
     * 
     * @type {Metadata}
     * @memberof FormList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof FormList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Form>}
     * @memberof FormList
     */
    'data'?: Array<Form>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject1
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject2
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject3
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject4
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject5
     */
    'metadata'?: Metadata;
}
/**
 * 
 * @export
 * @interface Interval
 */
export interface Interval {
    /**
     * Unique study key
     * @type {string}
     * @memberof Interval
     */
    'studyKey'?: string;
    /**
     * Unique system identifier for the interval (visit definition)
     * @type {number}
     * @memberof Interval
     */
    'intervalId'?: number;
    /**
     * Name of the interval (visit) as defined in the study
     * @type {string}
     * @memberof Interval
     */
    'intervalName'?: string;
    /**
     * Description of the interval (visit)
     * @type {string}
     * @memberof Interval
     */
    'intervalDescription'?: string;
    /**
     * Sequence number of the interval in the schedule
     * @type {number}
     * @memberof Interval
     */
    'intervalSequence'?: number;
    /**
     * Identifier for the interval group (if intervals are grouped)
     * @type {number}
     * @memberof Interval
     */
    'intervalGroupId'?: number;
    /**
     * Name of the interval group
     * @type {string}
     * @memberof Interval
     */
    'intervalGroupName'?: string;
    /**
     * Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)
     * @type {string}
     * @memberof Interval
     */
    'timeline'?: string;
    /**
     * Baseline interval used for calculating this interval’s dates
     * @type {string}
     * @memberof Interval
     */
    'definedUsingInterval'?: string;
    /**
     * Baseline form (name) from which the calculation date is taken
     * @type {string}
     * @memberof Interval
     */
    'windowCalculationForm'?: string;
    /**
     * Baseline field (variable name) from which the calculation date is taken
     * @type {string}
     * @memberof Interval
     */
    'windowCalculationDate'?: string;
    /**
     * Form used to capture the actual date for this interval
     * @type {string}
     * @memberof Interval
     */
    'actualDateForm'?: string;
    /**
     * Field (variable name) used to capture the actual date for this interval
     * @type {string}
     * @memberof Interval
     */
    'actualDate'?: string;
    /**
     * Number of days from the calculation date when the interval is due
     * @type {number}
     * @memberof Interval
     */
    'dueDateWillBeIn'?: number;
    /**
     * Number of days before the due date that are allowed (negative window)
     * @type {number}
     * @memberof Interval
     */
    'negativeSlack'?: number;
    /**
     * Number of days after the due date that are allowed (positive window)
     * @type {number}
     * @memberof Interval
     */
    'positiveSlack'?: number;
    /**
     * Number of days of grace period for ePRO completion after due date
     * @type {number}
     * @memberof Interval
     */
    'eproGracePeriod'?: number;
    /**
     * List of forms that are scheduled in this interval
     * @type {Array<ComponentsSchemasIntervalFormsItem>}
     * @memberof Interval
     */
    'forms'?: Array<ComponentsSchemasIntervalFormsItem>;
    /**
     * Whether the interval is soft-deleted (disabled)
     * @type {boolean}
     * @memberof Interval
     */
    'disabled'?: boolean;
    /**
     * Date when this interval was created
     * @type {string}
     * @memberof Interval
     */
    'dateCreated'?: string;
    /**
     * Date when this interval was last modified
     * @type {string}
     * @memberof Interval
     */
    'dateModified'?: string;
}
/**
 * 
 * @export
 * @interface IntervalList
 */
export interface IntervalList {
    /**
     * 
     * @type {Metadata}
     * @memberof IntervalList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof IntervalList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Interval>}
     * @memberof IntervalList
     */
    'data'?: Array<Interval>;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * Unique job identifier
     * @type {string}
     * @memberof Job
     */
    'jobId'?: string;
    /**
     * Batch ID associated with the job (useful for linking with record creation requests)
     * @type {string}
     * @memberof Job
     */
    'batchId'?: string;
    /**
     * State of the job (e.g., completed, pending)
     * @type {string}
     * @memberof Job
     */
    'state'?: string;
    /**
     * Timestamp when the job was created
     * @type {string}
     * @memberof Job
     */
    'dateCreated'?: string;
    /**
     * Timestamp when the job started processing
     * @type {string}
     * @memberof Job
     */
    'dateStarted'?: string;
    /**
     * Timestamp when the job finished processing
     * @type {string}
     * @memberof Job
     */
    'dateFinished'?: string;
}
/**
 * 
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * Name of the keyword
     * @type {string}
     * @memberof Keyword
     */
    'keywordName'?: string;
    /**
     * Key of the keyword (short code)
     * @type {string}
     * @memberof Keyword
     */
    'keywordKey'?: string;
    /**
     * Internal keyword ID
     * @type {number}
     * @memberof Keyword
     */
    'keywordId'?: number;
    /**
     * Date when this keyword was added
     * @type {string}
     * @memberof Keyword
     */
    'dateAdded'?: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * HTTP status of the response (e.g., OK or ERROR)
     * @type {string}
     * @memberof Metadata
     */
    'status'?: string;
    /**
     * HTTP method of the request
     * @type {string}
     * @memberof Metadata
     */
    'method'?: string;
    /**
     * Requested URI path
     * @type {string}
     * @memberof Metadata
     */
    'path'?: string;
    /**
     * Timestamp when response was generated
     * @type {string}
     * @memberof Metadata
     */
    'timestamp'?: string;
    /**
     * 
     * @type {ComponentsSchemasMetadataError}
     * @memberof Metadata
     */
    'error'?: ComponentsSchemasMetadataError;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Current index page returned
     * @type {number}
     * @memberof Pagination
     */
    'currentPage'?: number;
    /**
     * Number of items per page returned
     * @type {number}
     * @memberof Pagination
     */
    'size'?: number;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof Pagination
     */
    'totalPages'?: number;
    /**
     * Total number of elements (items) available
     * @type {number}
     * @memberof Pagination
     */
    'totalElements'?: number;
    /**
     * 
     * @type {Array<Sort>}
     * @memberof Pagination
     */
    'sort'?: Array<Sort>;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * Unique study key
     * @type {string}
     * @memberof Query
     */
    'studyKey'?: string;
    /**
     * Mednet subject ID associated with the query (if applicable)
     * @type {number}
     * @memberof Query
     */
    'subjectId'?: number;
    /**
     * Client-assigned subject OID (if applicable)
     * @type {string}
     * @memberof Query
     */
    'subjectOid'?: string;
    /**
     * Category/type of the query (e.g., subject, record, question)
     * @type {string}
     * @memberof Query
     */
    'annotationType'?: string;
    /**
     * Unique system identifier for the query
     * @type {number}
     * @memberof Query
     */
    'annotationId'?: number;
    /**
     * System text identifier for the query type/location (subject, record, question)
     * @type {string}
     * @memberof Query
     */
    'type'?: string;
    /**
     * Description of the query (e.g., reason or context)
     * @type {string}
     * @memberof Query
     */
    'description'?: string;
    /**
     * Record ID associated with the query (if applicable)
     * @type {number}
     * @memberof Query
     */
    'recordId'?: number;
    /**
     * Variable name (field) associated with the query (if applicable)
     * @type {string}
     * @memberof Query
     */
    'variable'?: string;
    /**
     * Subject display ID associated with the query (if applicable)
     * @type {string}
     * @memberof Query
     */
    'subjectKey'?: string;
    /**
     * Date when the query was created
     * @type {string}
     * @memberof Query
     */
    'dateCreated'?: string;
    /**
     * Date when the query was last modified
     * @type {string}
     * @memberof Query
     */
    'dateModified'?: string;
    /**
     * History of comments/actions on the query
     * @type {Array<QueryComment>}
     * @memberof Query
     */
    'queryComments'?: Array<QueryComment>;
}
/**
 * 
 * @export
 * @interface QueryComment
 */
export interface QueryComment {
    /**
     * Sequence number of the comment/action in the query history
     * @type {number}
     * @memberof QueryComment
     */
    'sequence'?: number;
    /**
     * Status of the query after this comment (e.g., Open, Closed)
     * @type {string}
     * @memberof QueryComment
     */
    'annotationStatus'?: string;
    /**
     * Username of the user who made the comment or action
     * @type {string}
     * @memberof QueryComment
     */
    'user'?: string;
    /**
     * Text of the comment
     * @type {string}
     * @memberof QueryComment
     */
    'comment'?: string;
    /**
     * Whether the query was marked closed at this step
     * @type {boolean}
     * @memberof QueryComment
     */
    'closed'?: boolean;
    /**
     * Date of the comment or action
     * @type {string}
     * @memberof QueryComment
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface QueryList
 */
export interface QueryList {
    /**
     * 
     * @type {Metadata}
     * @memberof QueryList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof QueryList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Query>}
     * @memberof QueryList
     */
    'data'?: Array<Query>;
}
/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * Unique study key
     * @type {string}
     * @memberof Record
     */
    'studyKey'?: string;
    /**
     * Interval ID (visit definition) that this record is associated with
     * @type {number}
     * @memberof Record
     */
    'intervalId'?: number;
    /**
     * Form ID of the form this record instance belongs to
     * @type {number}
     * @memberof Record
     */
    'formId'?: number;
    /**
     * Form key of the form for this record instance
     * @type {string}
     * @memberof Record
     */
    'formKey'?: string;
    /**
     * Site ID associated with the record
     * @type {number}
     * @memberof Record
     */
    'siteId'?: number;
    /**
     * Unique record ID
     * @type {number}
     * @memberof Record
     */
    'recordId'?: number;
    /**
     * Client-assigned record OID
     * @type {string}
     * @memberof Record
     */
    'recordOid'?: string;
    /**
     * Type of record (e.g., SUBJECT for subject-related forms)
     * @type {string}
     * @memberof Record
     */
    'recordType'?: string;
    /**
     * Current status of the record (e.g., Record Incomplete, Record Complete)
     * @type {string}
     * @memberof Record
     */
    'recordStatus'?: string;
    /**
     * Whether the record is marked as deleted
     * @type {boolean}
     * @memberof Record
     */
    'deleted'?: boolean;
    /**
     * Date when this record was created
     * @type {string}
     * @memberof Record
     */
    'dateCreated'?: string;
    /**
     * Date when this record was last modified
     * @type {string}
     * @memberof Record
     */
    'dateModified'?: string;
    /**
     * Mednet subject ID that this record is associated with
     * @type {number}
     * @memberof Record
     */
    'subjectId'?: number;
    /**
     * Client-assigned subject OID for the subject this record is associated with
     * @type {string}
     * @memberof Record
     */
    'subjectOid'?: string;
    /**
     * Subject display ID that this record is associated with
     * @type {string}
     * @memberof Record
     */
    'subjectKey'?: string;
    /**
     * Visit instance ID that this record is associated with (if applicable)
     * @type {number}
     * @memberof Record
     */
    'visitId'?: number;
    /**
     * Record ID of the parent record if this record is a subrecord (if applicable)
     * @type {number}
     * @memberof Record
     */
    'parentRecordId'?: number;
    /**
     * List of keywords associated with the record
     * @type {Array<Keyword>}
     * @memberof Record
     */
    'keywords'?: Array<Keyword>;
    /**
     * Data fields and values captured in this record. The structure is dynamic, with keys corresponding to variable names.
     * @type {{ [key: string]: any; }}
     * @memberof Record
     */
    'recordData'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RecordJobStatus
 */
export interface RecordJobStatus {
    /**
     * Unique job identifier
     * @type {string}
     * @memberof RecordJobStatus
     */
    'jobId'?: string;
    /**
     * Batch ID used to track the job (identical to jobId in most cases)
     * @type {string}
     * @memberof RecordJobStatus
     */
    'batchId'?: string;
    /**
     * Current state of the job (e.g., created, completed)
     * @type {string}
     * @memberof RecordJobStatus
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface RecordList
 */
export interface RecordList {
    /**
     * 
     * @type {Metadata}
     * @memberof RecordList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof RecordList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Record>}
     * @memberof RecordList
     */
    'data'?: Array<Record>;
}
/**
 * 
 * @export
 * @interface RecordRevision
 */
export interface RecordRevision {
    /**
     * Unique study key
     * @type {string}
     * @memberof RecordRevision
     */
    'studyKey'?: string;
    /**
     * Unique system identifier for the record revision
     * @type {number}
     * @memberof RecordRevision
     */
    'recordRevisionId'?: number;
    /**
     * Unique system identifier of the related record
     * @type {number}
     * @memberof RecordRevision
     */
    'recordId'?: number;
    /**
     * Client-assigned record OID (if any)
     * @type {string}
     * @memberof RecordRevision
     */
    'recordOid'?: string;
    /**
     * Revision number of the record (version of the record status)
     * @type {number}
     * @memberof RecordRevision
     */
    'recordRevision'?: number;
    /**
     * Revision number of the data within the record
     * @type {number}
     * @memberof RecordRevision
     */
    'dataRevision'?: number;
    /**
     * Status of the record at this revision (user-defined status label)
     * @type {string}
     * @memberof RecordRevision
     */
    'recordStatus'?: string;
    /**
     * Mednet subject ID related to the record
     * @type {number}
     * @memberof RecordRevision
     */
    'subjectId'?: number;
    /**
     * Client-assigned subject OID related to the record
     * @type {string}
     * @memberof RecordRevision
     */
    'subjectOid'?: string;
    /**
     * Subject display ID related to the record
     * @type {string}
     * @memberof RecordRevision
     */
    'subjectKey'?: string;
    /**
     * Site ID related to the record
     * @type {number}
     * @memberof RecordRevision
     */
    'siteId'?: number;
    /**
     * Form key of the form that the record belongs to
     * @type {string}
     * @memberof RecordRevision
     */
    'formKey'?: string;
    /**
     * Interval ID (visit definition) related to the record
     * @type {number}
     * @memberof RecordRevision
     */
    'intervalId'?: number;
    /**
     * Role name of the user who saved the record revision
     * @type {string}
     * @memberof RecordRevision
     */
    'role'?: string;
    /**
     * Username of the user who saved the record revision
     * @type {string}
     * @memberof RecordRevision
     */
    'user'?: string;
    /**
     * Reason for change, if provided (for audit trail)
     * @type {string}
     * @memberof RecordRevision
     */
    'reasonForChange'?: string;
    /**
     * Whether the record was deleted in this revision
     * @type {boolean}
     * @memberof RecordRevision
     */
    'deleted'?: boolean;
    /**
     * Date when this record revision was created
     * @type {string}
     * @memberof RecordRevision
     */
    'dateCreated'?: string;
}
/**
 * 
 * @export
 * @interface RecordRevisionList
 */
export interface RecordRevisionList {
    /**
     * 
     * @type {Metadata}
     * @memberof RecordRevisionList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof RecordRevisionList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<RecordRevision>}
     * @memberof RecordRevisionList
     */
    'data'?: Array<RecordRevision>;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * Timestamp when the role assignment was created (as [year, month, day, hour, minute, second, nanosecond])
     * @type {Array<number>}
     * @memberof Role
     */
    'dateCreated'?: Array<number>;
    /**
     * Timestamp when the role assignment was last modified
     * @type {Array<number>}
     * @memberof Role
     */
    'dateModified'?: Array<number>;
    /**
     * Unique role ID (UUID)
     * @type {string}
     * @memberof Role
     */
    'roleId'?: string;
    /**
     * Community ID or level associated with the role
     * @type {number}
     * @memberof Role
     */
    'communityId'?: number;
    /**
     * Name of the role
     * @type {string}
     * @memberof Role
     */
    'name'?: string;
    /**
     * Description of the role
     * @type {string}
     * @memberof Role
     */
    'description'?: string;
    /**
     * Role level or hierarchy
     * @type {number}
     * @memberof Role
     */
    'level'?: number;
    /**
     * Role type/category
     * @type {string}
     * @memberof Role
     */
    'type'?: string;
    /**
     * Whether the role is inactive
     * @type {boolean}
     * @memberof Role
     */
    'inactive'?: boolean;
}
/**
 * 
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * Unique study key
     * @type {string}
     * @memberof Site
     */
    'studyKey'?: string;
    /**
     * Unique site ID
     * @type {number}
     * @memberof Site
     */
    'siteId'?: number;
    /**
     * Name of the site
     * @type {string}
     * @memberof Site
     */
    'siteName'?: string;
    /**
     * Enrollment status of the site
     * @type {string}
     * @memberof Site
     */
    'siteEnrollmentStatus'?: string;
    /**
     * Date when this site was created
     * @type {string}
     * @memberof Site
     */
    'dateCreated'?: string;
    /**
     * Date when this site was last modified
     * @type {string}
     * @memberof Site
     */
    'dateModified'?: string;
}
/**
 * 
 * @export
 * @interface SiteList
 */
export interface SiteList {
    /**
     * 
     * @type {Metadata}
     * @memberof SiteList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof SiteList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Site>}
     * @memberof SiteList
     */
    'data'?: Array<Site>;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * Name of the property by which the result is sorted
     * @type {string}
     * @memberof Sort
     */
    'property'?: string;
    /**
     * Sort direction (ASC or DESC)
     * @type {string}
     * @memberof Sort
     */
    'direction'?: SortDirectionEnum;
}

export const SortDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type SortDirectionEnum = typeof SortDirectionEnum[keyof typeof SortDirectionEnum];

/**
 * 
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * Sponsor key that this study belongs to
     * @type {string}
     * @memberof Study
     */
    'sponsorKey'?: string;
    /**
     * Unique study key
     * @type {string}
     * @memberof Study
     */
    'studyKey'?: string;
    /**
     * Mednet study ID (internal numeric identifier)
     * @type {number}
     * @memberof Study
     */
    'studyId'?: number;
    /**
     * Name of the study
     * @type {string}
     * @memberof Study
     */
    'studyName'?: string;
    /**
     * Description of the study
     * @type {string}
     * @memberof Study
     */
    'studyDescription'?: string;
    /**
     * Type of study (e.g., STUDY)
     * @type {string}
     * @memberof Study
     */
    'studyType'?: string;
    /**
     * Date when the study record was created
     * @type {string}
     * @memberof Study
     */
    'dateCreated'?: string;
    /**
     * Date when the study record was last modified
     * @type {string}
     * @memberof Study
     */
    'dateModified'?: string;
}
/**
 * 
 * @export
 * @interface StudyList
 */
export interface StudyList {
    /**
     * 
     * @type {Metadata}
     * @memberof StudyList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof StudyList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Study>}
     * @memberof StudyList
     */
    'data'?: Array<Study>;
}
/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * Unique study key
     * @type {string}
     * @memberof Subject
     */
    'studyKey'?: string;
    /**
     * Mednet subject ID (internal numeric ID)
     * @type {number}
     * @memberof Subject
     */
    'subjectId'?: number;
    /**
     * Client-assigned subject object identifier (OID)
     * @type {string}
     * @memberof Subject
     */
    'subjectOid'?: string;
    /**
     * Protocol-assigned subject identifier (display ID)
     * @type {string}
     * @memberof Subject
     */
    'subjectKey'?: string;
    /**
     * Current status of the subject (e.g., Enrolled)
     * @type {string}
     * @memberof Subject
     */
    'subjectStatus'?: string;
    /**
     * Mednet site ID the subject is associated with
     * @type {number}
     * @memberof Subject
     */
    'siteId'?: number;
    /**
     * Name of the site the subject is associated with
     * @type {string}
     * @memberof Subject
     */
    'siteName'?: string;
    /**
     * Whether the subject is marked as deleted
     * @type {boolean}
     * @memberof Subject
     */
    'deleted'?: boolean;
    /**
     * Subject’s enrollment start date
     * @type {string}
     * @memberof Subject
     */
    'enrollmentStartDate'?: string;
    /**
     * Date when this subject record was created
     * @type {string}
     * @memberof Subject
     */
    'dateCreated'?: string;
    /**
     * Date when this subject record was last modified
     * @type {string}
     * @memberof Subject
     */
    'dateModified'?: string;
    /**
     * List of keywords associated with the subject
     * @type {Array<Keyword>}
     * @memberof Subject
     */
    'keywords'?: Array<Keyword>;
}
/**
 * 
 * @export
 * @interface SubjectList
 */
export interface SubjectList {
    /**
     * 
     * @type {Metadata}
     * @memberof SubjectList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof SubjectList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Subject>}
     * @memberof SubjectList
     */
    'data'?: Array<Subject>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique user ID (UUID)
     * @type {string}
     * @memberof User
     */
    'userId'?: string;
    /**
     * User login name
     * @type {string}
     * @memberof User
     */
    'login'?: string;
    /**
     * User first name
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * User last name
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * User email address
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * Whether the user is active in the given study
     * @type {boolean}
     * @memberof User
     */
    'userActiveInStudy'?: boolean;
    /**
     * Roles that the user has in the study
     * @type {Array<Role>}
     * @memberof User
     */
    'roles'?: Array<Role>;
}
/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {Metadata}
     * @memberof UserList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof UserList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList
     */
    'data'?: Array<User>;
}
/**
 * 
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * Unique study key
     * @type {string}
     * @memberof Variable
     */
    'studyKey'?: string;
    /**
     * Mednet variable ID
     * @type {number}
     * @memberof Variable
     */
    'variableId'?: number;
    /**
     * Type of the variable (field type), e.g., RADIO, TEXT, etc.
     * @type {string}
     * @memberof Variable
     */
    'variableType'?: VariableVariableTypeEnum;
    /**
     * Name of the variable (question text or label)
     * @type {string}
     * @memberof Variable
     */
    'variableName'?: string;
    /**
     * Sequence of the variable on the form
     * @type {number}
     * @memberof Variable
     */
    'sequence'?: number;
    /**
     * Number of modifications of the variable (via form metadata revisions)
     * @type {number}
     * @memberof Variable
     */
    'revision'?: number;
    /**
     * Whether the variable is marked as disabled (deleted)
     * @type {boolean}
     * @memberof Variable
     */
    'disabled'?: boolean;
    /**
     * Date when this variable was created
     * @type {string}
     * @memberof Variable
     */
    'dateCreated'?: string;
    /**
     * Date when this variable was last modified
     * @type {string}
     * @memberof Variable
     */
    'dateModified'?: string;
    /**
     * ID of the form that this variable belongs to
     * @type {number}
     * @memberof Variable
     */
    'formId'?: number;
    /**
     * Client-assigned variable OID
     * @type {string}
     * @memberof Variable
     */
    'variableOid'?: string;
    /**
     * Whether the variable is marked as deleted
     * @type {boolean}
     * @memberof Variable
     */
    'deleted'?: boolean;
    /**
     * Form key of the form that this variable belongs to
     * @type {string}
     * @memberof Variable
     */
    'formKey'?: string;
    /**
     * Name of the form that this variable belongs to
     * @type {string}
     * @memberof Variable
     */
    'formName'?: string;
    /**
     * User-defined identifier (field name) for the variable
     * @type {string}
     * @memberof Variable
     */
    'label'?: string;
    /**
     * Whether the variable is flagged as blinded (hidden in certain contexts)
     * @type {boolean}
     * @memberof Variable
     */
    'blinded'?: boolean;
}

export const VariableVariableTypeEnum = {
    Text: 'TEXT',
    Textarea: 'TEXTAREA',
    Radio: 'RADIO',
    Checkbox: 'CHECKBOX',
    Dropdown: 'DROPDOWN',
    Date: 'DATE',
    Number: 'NUMBER'
} as const;

export type VariableVariableTypeEnum = typeof VariableVariableTypeEnum[keyof typeof VariableVariableTypeEnum];

/**
 * 
 * @export
 * @interface VariableList
 */
export interface VariableList {
    /**
     * 
     * @type {Metadata}
     * @memberof VariableList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof VariableList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof VariableList
     */
    'data'?: Array<Variable>;
}
/**
 * 
 * @export
 * @interface Visit
 */
export interface Visit {
    /**
     * Unique study key
     * @type {string}
     * @memberof Visit
     */
    'studyKey'?: string;
    /**
     * Unique system identifier for the subject visit instance
     * @type {number}
     * @memberof Visit
     */
    'visitId'?: number;
    /**
     * Unique system identifier of the interval definition for this visit
     * @type {number}
     * @memberof Visit
     */
    'intervalId'?: number;
    /**
     * Name of the interval (visit) for this visit instance
     * @type {string}
     * @memberof Visit
     */
    'intervalName'?: string;
    /**
     * Mednet subject ID of the subject
     * @type {number}
     * @memberof Visit
     */
    'subjectId'?: number;
    /**
     * Protocol-assigned subject identifier
     * @type {string}
     * @memberof Visit
     */
    'subjectKey'?: string;
    /**
     * Start date of the visit window (in YYYY-MM-DD format)
     * @type {string}
     * @memberof Visit
     */
    'startDate'?: string;
    /**
     * End date of the visit window (in YYYY-MM-DD format)
     * @type {string}
     * @memberof Visit
     */
    'endDate'?: string;
    /**
     * Due date of the visit (in YYYY-MM-DD format), if applicable
     * @type {string}
     * @memberof Visit
     */
    'dueDate'?: string;
    /**
     * Actual date the visit took place (in YYYY-MM-DD format)
     * @type {string}
     * @memberof Visit
     */
    'visitDate'?: string;
    /**
     * Name of the form used to capture the actual visit date
     * @type {string}
     * @memberof Visit
     */
    'visitDateForm'?: string;
    /**
     * Variable name of the field capturing the actual visit date
     * @type {string}
     * @memberof Visit
     */
    'visitDateQuestion'?: string;
    /**
     * Whether the visit instance is marked as deleted
     * @type {boolean}
     * @memberof Visit
     */
    'deleted'?: boolean;
    /**
     * Date when this visit record was created
     * @type {string}
     * @memberof Visit
     */
    'dateCreated'?: string;
    /**
     * Date when this visit record was last modified
     * @type {string}
     * @memberof Visit
     */
    'dateModified'?: string;
}
/**
 * 
 * @export
 * @interface VisitList
 */
export interface VisitList {
    /**
     * 
     * @type {Metadata}
     * @memberof VisitList
     */
    'metadata'?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof VisitList
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Visit>}
     * @memberof VisitList
     */
    'data'?: Array<Visit>;
}

/**
 * AdministrationApi - axios parameter creator
 * @export
 */
export const AdministrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List users and their roles in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {boolean} [includeInactive] For user listing, whether to include inactive users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listUsers', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/users`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['includeInactive'] = includeInactive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdministrationApi - functional programming interface
 * @export
 */
export const AdministrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdministrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List users and their roles in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {boolean} [includeInactive] For user listing, whether to include inactive users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(studyKey, page, size, sort, includeInactive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministrationApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdministrationApi - factory interface
 * @export
 */
export const AdministrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdministrationApiFp(configuration)
    return {
        /**
         * 
         * @summary List users and their roles in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {boolean} [includeInactive] For user listing, whether to include inactive users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<UserList> {
            return localVarFp.listUsers(studyKey, page, size, sort, includeInactive, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdministrationApi - object-oriented interface
 * @export
 * @class AdministrationApi
 * @extends {BaseAPI}
 */
export class AdministrationApi extends BaseAPI {
    /**
     * 
     * @summary List users and their roles in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {boolean} [includeInactive] For user listing, whether to include inactive users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministrationApi
     */
    public listUsers(studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options?: RawAxiosRequestConfig) {
        return AdministrationApiFp(this.configuration).listUsers(studyKey, page, size, sort, includeInactive, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CodingsApi - axios parameter creator
 * @export
 */
export const CodingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List coding activities in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCodings: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listCodings', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/codings`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodingsApi - functional programming interface
 * @export
 */
export const CodingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CodingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List coding activities in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCodings(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodingList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCodings(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CodingsApi.listCodings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CodingsApi - factory interface
 * @export
 */
export const CodingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CodingsApiFp(configuration)
    return {
        /**
         * 
         * @summary List coding activities in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCodings(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<CodingList> {
            return localVarFp.listCodings(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CodingsApi - object-oriented interface
 * @export
 * @class CodingsApi
 * @extends {BaseAPI}
 */
export class CodingsApi extends BaseAPI {
    /**
     * 
     * @summary List coding activities in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodingsApi
     */
    public listCodings(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return CodingsApiFp(this.configuration).listCodings(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FormsApi - axios parameter creator
 * @export
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List forms in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForms: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listForms', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/forms`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormsApi - functional programming interface
 * @export
 */
export const FormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List forms in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForms(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForms(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.listForms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FormsApi - factory interface
 * @export
 */
export const FormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormsApiFp(configuration)
    return {
        /**
         * 
         * @summary List forms in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForms(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<FormList> {
            return localVarFp.listForms(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FormsApi - object-oriented interface
 * @export
 * @class FormsApi
 * @extends {BaseAPI}
 */
export class FormsApi extends BaseAPI {
    /**
     * 
     * @summary List forms in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public listForms(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).listForms(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntervalsApi - axios parameter creator
 * @export
 */
export const IntervalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List intervals (visit definitions) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntervals: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listIntervals', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/intervals`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntervalsApi - functional programming interface
 * @export
 */
export const IntervalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntervalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List intervals (visit definitions) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIntervals(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntervalList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIntervals(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntervalsApi.listIntervals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntervalsApi - factory interface
 * @export
 */
export const IntervalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntervalsApiFp(configuration)
    return {
        /**
         * 
         * @summary List intervals (visit definitions) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntervals(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<IntervalList> {
            return localVarFp.listIntervals(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntervalsApi - object-oriented interface
 * @export
 * @class IntervalsApi
 * @extends {BaseAPI}
 */
export class IntervalsApi extends BaseAPI {
    /**
     * 
     * @summary List intervals (visit definitions) in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntervalsApi
     */
    public listIntervals(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return IntervalsApiFp(this.configuration).listIntervals(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve job status by batch ID
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {string} batchId Batch ID of the job to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (studyKey: string, batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('getJobStatus', 'studyKey', studyKey)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getJobStatus', 'batchId', batchId)
            const localVarPath = `/studies/{studyKey}/jobs/{batchId}`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)))
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve job status by batch ID
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {string} batchId Batch ID of the job to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(studyKey: string, batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(studyKey, batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve job status by batch ID
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {string} batchId Batch ID of the job to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(studyKey: string, batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<Job> {
            return localVarFp.getJobStatus(studyKey, batchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve job status by batch ID
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {string} batchId Batch ID of the job to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobStatus(studyKey: string, batchId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobStatus(studyKey, batchId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueriesApi - axios parameter creator
 * @export
 */
export const QueriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List data queries in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueries: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listQueries', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/queries`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List data queries in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQueries(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQueries(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueriesApi.listQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueriesApiFp(configuration)
    return {
        /**
         * 
         * @summary List data queries in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueries(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryList> {
            return localVarFp.listQueries(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
    /**
     * 
     * @summary List data queries in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public listQueries(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return QueriesApiFp(this.configuration).listQueries(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecordRevisionsApi - axios parameter creator
 * @export
 */
export const RecordRevisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List record revisions (audit trail entries) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordRevisions: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listRecordRevisions', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/recordRevisions`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordRevisionsApi - functional programming interface
 * @export
 */
export const RecordRevisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordRevisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List record revisions (audit trail entries) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecordRevisions(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordRevisionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecordRevisions(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordRevisionsApi.listRecordRevisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecordRevisionsApi - factory interface
 * @export
 */
export const RecordRevisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordRevisionsApiFp(configuration)
    return {
        /**
         * 
         * @summary List record revisions (audit trail entries) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordRevisions(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<RecordRevisionList> {
            return localVarFp.listRecordRevisions(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordRevisionsApi - object-oriented interface
 * @export
 * @class RecordRevisionsApi
 * @extends {BaseAPI}
 */
export class RecordRevisionsApi extends BaseAPI {
    /**
     * 
     * @summary List record revisions (audit trail entries) in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordRevisionsApi
     */
    public listRecordRevisions(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return RecordRevisionsApiFp(this.configuration).listRecordRevisions(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecordsApi - axios parameter creator
 * @export
 */
export const RecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new record or update subject/record data
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {Array<ComponentsSchemasRecordCreateRequestItem>} componentsSchemasRecordCreateRequestItem An array of record objects defining the operation to perform (subject registration, record creation, or scheduled record update).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecords: async (studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('createRecords', 'studyKey', studyKey)
            // verify required parameter 'componentsSchemasRecordCreateRequestItem' is not null or undefined
            assertParamExists('createRecords', 'componentsSchemasRecordCreateRequestItem', componentsSchemasRecordCreateRequestItem)
            const localVarPath = `/studies/{studyKey}/records`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(componentsSchemasRecordCreateRequestItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List records (eCRF instances) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {string} [recordDataFilter] Optional filter criteria to apply on recordData fields (question responses). Supports &#x3D;&#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;~ (contains) and can combine multiple criteria with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecords: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listRecords', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/records`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (recordDataFilter !== undefined) {
                localVarQueryParameter['recordDataFilter'] = recordDataFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordsApi - functional programming interface
 * @export
 */
export const RecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new record or update subject/record data
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {Array<ComponentsSchemasRecordCreateRequestItem>} componentsSchemasRecordCreateRequestItem An array of record objects defining the operation to perform (subject registration, record creation, or scheduled record update).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecords(studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordJobStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecords(studyKey, componentsSchemasRecordCreateRequestItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.createRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List records (eCRF instances) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {string} [recordDataFilter] Optional filter criteria to apply on recordData fields (question responses). Supports &#x3D;&#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;~ (contains) and can combine multiple criteria with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecords(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecords(studyKey, page, size, sort, filter, recordDataFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.listRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecordsApi - factory interface
 * @export
 */
export const RecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new record or update subject/record data
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {Array<ComponentsSchemasRecordCreateRequestItem>} componentsSchemasRecordCreateRequestItem An array of record objects defining the operation to perform (subject registration, record creation, or scheduled record update).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecords(studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options?: RawAxiosRequestConfig): AxiosPromise<RecordJobStatus> {
            return localVarFp.createRecords(studyKey, componentsSchemasRecordCreateRequestItem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List records (eCRF instances) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {string} [recordDataFilter] Optional filter criteria to apply on recordData fields (question responses). Supports &#x3D;&#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;~ (contains) and can combine multiple criteria with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecords(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options?: RawAxiosRequestConfig): AxiosPromise<RecordList> {
            return localVarFp.listRecords(studyKey, page, size, sort, filter, recordDataFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordsApi - object-oriented interface
 * @export
 * @class RecordsApi
 * @extends {BaseAPI}
 */
export class RecordsApi extends BaseAPI {
    /**
     * 
     * @summary Add new record or update subject/record data
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {Array<ComponentsSchemasRecordCreateRequestItem>} componentsSchemasRecordCreateRequestItem An array of record objects defining the operation to perform (subject registration, record creation, or scheduled record update).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public createRecords(studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).createRecords(studyKey, componentsSchemasRecordCreateRequestItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List records (eCRF instances) in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {string} [recordDataFilter] Optional filter criteria to apply on recordData fields (question responses). Supports &#x3D;&#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;~ (contains) and can combine multiple criteria with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public listRecords(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).listRecords(studyKey, page, size, sort, filter, recordDataFilter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SitesApi - axios parameter creator
 * @export
 */
export const SitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List sites for a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listSites', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/sites`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitesApi - functional programming interface
 * @export
 */
export const SitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List sites for a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSites(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSites(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SitesApi.listSites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SitesApi - factory interface
 * @export
 */
export const SitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitesApiFp(configuration)
    return {
        /**
         * 
         * @summary List sites for a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSites(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<SiteList> {
            return localVarFp.listSites(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitesApi - object-oriented interface
 * @export
 * @class SitesApi
 * @extends {BaseAPI}
 */
export class SitesApi extends BaseAPI {
    /**
     * 
     * @summary List sites for a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public listSites(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return SitesApiFp(this.configuration).listSites(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List studies accessible by API key
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudies: async (page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List studies accessible by API key
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStudies(page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStudies(page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.listStudies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * 
         * @summary List studies accessible by API key
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudies(page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<StudyList> {
            return localVarFp.listStudies(page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * 
     * @summary List studies accessible by API key
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public listStudies(page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).listStudies(page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubjectsApi - axios parameter creator
 * @export
 */
export const SubjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List subjects in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubjects: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listSubjects', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/subjects`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubjectsApi - functional programming interface
 * @export
 */
export const SubjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List subjects in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubjects(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubjectList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubjects(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectsApi.listSubjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubjectsApi - factory interface
 * @export
 */
export const SubjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary List subjects in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubjects(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<SubjectList> {
            return localVarFp.listSubjects(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubjectsApi - object-oriented interface
 * @export
 * @class SubjectsApi
 * @extends {BaseAPI}
 */
export class SubjectsApi extends BaseAPI {
    /**
     * 
     * @summary List subjects in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectsApi
     */
    public listSubjects(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return SubjectsApiFp(this.configuration).listSubjects(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariablesApi - axios parameter creator
 * @export
 */
export const VariablesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List variables (fields) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listVariables', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/variables`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariablesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List variables (fields) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVariables(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVariables(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariablesApi.listVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariablesApiFp(configuration)
    return {
        /**
         * 
         * @summary List variables (fields) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVariables(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableList> {
            return localVarFp.listVariables(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI {
    /**
     * 
     * @summary List variables (fields) in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public listVariables(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return VariablesApiFp(this.configuration).listVariables(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VisitsApi - axios parameter creator
 * @export
 */
export const VisitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List visits (subject visit instances) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVisits: async (studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyKey' is not null or undefined
            assertParamExists('listVisits', 'studyKey', studyKey)
            const localVarPath = `/studies/{studyKey}/visits`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication securityKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-imn-security-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisitsApi - functional programming interface
 * @export
 */
export const VisitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List visits (subject visit instances) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVisits(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVisits(studyKey, page, size, sort, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VisitsApi.listVisits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VisitsApi - factory interface
 * @export
 */
export const VisitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisitsApiFp(configuration)
    return {
        /**
         * 
         * @summary List visits (subject visit instances) in a study
         * @param {string} studyKey Study key identifying the study context for the request
         * @param {number} [page] Page index to retrieve (0-based)
         * @param {number} [size] Number of items to return per page (max 500)
         * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
         * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVisits(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<VisitList> {
            return localVarFp.listVisits(studyKey, page, size, sort, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisitsApi - object-oriented interface
 * @export
 * @class VisitsApi
 * @extends {BaseAPI}
 */
export class VisitsApi extends BaseAPI {
    /**
     * 
     * @summary List visits (subject visit instances) in a study
     * @param {string} studyKey Study key identifying the study context for the request
     * @param {number} [page] Page index to retrieve (0-based)
     * @param {number} [size] Number of items to return per page (max 500)
     * @param {string} [sort] Sorting criteria in the format &#x60;property,ASC&#x60; or &#x60;property,DESC&#x60;. Can be repeated.
     * @param {string} [filter] Optional filter criteria to apply, in the format &#x60;attribute&#x3D;&#x3D;value&#x60; with support for &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, !&#x3D;. Multiple criteria can be combined with &#x60;;&#x60; (AND) or &#x60;,&#x60; (OR).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisitsApi
     */
    public listVisits(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RawAxiosRequestConfig) {
        return VisitsApiFp(this.configuration).listVisits(studyKey, page, size, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



