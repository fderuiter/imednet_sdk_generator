{-
   Mednet EDC API

   The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 

   OpenAPI Version: 3.1.0
   Mednet EDC API API version: 1.3.6
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : MednetEDC.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module MednetEDC.Model where

import MednetEDC.Core
import MednetEDC.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** BatchId
newtype BatchId = BatchId { unBatchId :: Text } deriving (P.Eq, P.Show)

-- ** ComponentsSchemasRecordCreateRequestItem2
newtype ComponentsSchemasRecordCreateRequestItem2 = ComponentsSchemasRecordCreateRequestItem2 { unComponentsSchemasRecordCreateRequestItem2 :: [ComponentsSchemasRecordCreateRequestItem] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** IncludeInactive
newtype IncludeInactive = IncludeInactive { unIncludeInactive :: Bool } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Int } deriving (P.Eq, P.Show)

-- ** RecordDataFilter
newtype RecordDataFilter = RecordDataFilter { unRecordDataFilter :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Int } deriving (P.Eq, P.Show)

-- ** Sort2
newtype Sort2 = Sort2 { unSort2 :: Text } deriving (P.Eq, P.Show)

-- ** StudyKey
newtype StudyKey = StudyKey { unStudyKey :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Coding
-- | Coding
-- Coding
-- 
data Coding = Coding
  { codingStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , codingSiteName :: !(Maybe Text) -- ^ "siteName" - Name of the site associated with the coded data
  , codingSiteId :: !(Maybe Int) -- ^ "siteId" - Site ID associated with the coded data
  , codingSubjectId :: !(Maybe Int) -- ^ "subjectId" - Subject ID associated with the coded data
  , codingSubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Subject key (display ID) associated with the coded data
  , codingFormId :: !(Maybe Int) -- ^ "formId" - Form ID where the coded data originates
  , codingFormName :: !(Maybe Text) -- ^ "formName" - Name of the form where the coded data originates
  , codingFormKey :: !(Maybe Text) -- ^ "formKey" - Form key where the coded data originates
  , codingRevision :: !(Maybe Int) -- ^ "revision" - Revision number of the coding entry
  , codingRecordId :: !(Maybe Int) -- ^ "recordId" - Record ID associated with the coded data
  , codingVariable :: !(Maybe Text) -- ^ "variable" - Variable name (field) that was coded
  , codingValue :: !(Maybe Text) -- ^ "value" - Original value entered that required coding
  , codingCodingId :: !(Maybe Int) -- ^ "codingId" - Mednet coding ID
  , codingCode :: !(Maybe Text) -- ^ "code" - Standardized code assigned (e.g., dictionary term)
  , codingCodedBy :: !(Maybe Text) -- ^ "codedBy" - Name of the user who performed the coding
  , codingReason :: !(Maybe Text) -- ^ "reason" - Reason for coding or any notes on changes
  , codingDictionaryName :: !(Maybe Text) -- ^ "dictionaryName" - Name of the dictionary used (e.g., MedDRA)
  , codingDictionaryVersion :: !(Maybe Text) -- ^ "dictionaryVersion" - Version of the dictionary used
  , codingDateCoded :: !(Maybe Text) -- ^ "dateCoded" - Date when the coding was performed
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Coding
instance A.FromJSON Coding where
  parseJSON = A.withObject "Coding" $ \o ->
    Coding
      <$> (o .:? "studyKey")
      <*> (o .:? "siteName")
      <*> (o .:? "siteId")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectKey")
      <*> (o .:? "formId")
      <*> (o .:? "formName")
      <*> (o .:? "formKey")
      <*> (o .:? "revision")
      <*> (o .:? "recordId")
      <*> (o .:? "variable")
      <*> (o .:? "value")
      <*> (o .:? "codingId")
      <*> (o .:? "code")
      <*> (o .:? "codedBy")
      <*> (o .:? "reason")
      <*> (o .:? "dictionaryName")
      <*> (o .:? "dictionaryVersion")
      <*> (o .:? "dateCoded")

-- | ToJSON Coding
instance A.ToJSON Coding where
  toJSON Coding {..} =
   _omitNulls
      [ "studyKey" .= codingStudyKey
      , "siteName" .= codingSiteName
      , "siteId" .= codingSiteId
      , "subjectId" .= codingSubjectId
      , "subjectKey" .= codingSubjectKey
      , "formId" .= codingFormId
      , "formName" .= codingFormName
      , "formKey" .= codingFormKey
      , "revision" .= codingRevision
      , "recordId" .= codingRecordId
      , "variable" .= codingVariable
      , "value" .= codingValue
      , "codingId" .= codingCodingId
      , "code" .= codingCode
      , "codedBy" .= codingCodedBy
      , "reason" .= codingReason
      , "dictionaryName" .= codingDictionaryName
      , "dictionaryVersion" .= codingDictionaryVersion
      , "dateCoded" .= codingDateCoded
      ]


-- | Construct a value of type 'Coding' (by applying it's required fields, if any)
mkCoding
  :: Coding
mkCoding =
  Coding
  { codingStudyKey = Nothing
  , codingSiteName = Nothing
  , codingSiteId = Nothing
  , codingSubjectId = Nothing
  , codingSubjectKey = Nothing
  , codingFormId = Nothing
  , codingFormName = Nothing
  , codingFormKey = Nothing
  , codingRevision = Nothing
  , codingRecordId = Nothing
  , codingVariable = Nothing
  , codingValue = Nothing
  , codingCodingId = Nothing
  , codingCode = Nothing
  , codingCodedBy = Nothing
  , codingReason = Nothing
  , codingDictionaryName = Nothing
  , codingDictionaryVersion = Nothing
  , codingDateCoded = Nothing
  }

-- ** CodingList
-- | CodingList
-- CodingList
-- 
data CodingList = CodingList
  { codingListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , codingListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , codingListData :: !(Maybe [Coding]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CodingList
instance A.FromJSON CodingList where
  parseJSON = A.withObject "CodingList" $ \o ->
    CodingList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON CodingList
instance A.ToJSON CodingList where
  toJSON CodingList {..} =
   _omitNulls
      [ "metadata" .= codingListMetadata
      , "pagination" .= codingListPagination
      , "data" .= codingListData
      ]


-- | Construct a value of type 'CodingList' (by applying it's required fields, if any)
mkCodingList
  :: CodingList
mkCodingList =
  CodingList
  { codingListMetadata = Nothing
  , codingListPagination = Nothing
  , codingListData = Nothing
  }

-- ** ComponentsSchemasIntervalFormsItem
-- | ComponentsSchemasIntervalFormsItem
-- components_schemas_Interval_forms_item
-- 
data ComponentsSchemasIntervalFormsItem = ComponentsSchemasIntervalFormsItem
  { componentsSchemasIntervalFormsItemFormId :: !(Maybe Int) -- ^ "formId" - Form ID scheduled in the interval
  , componentsSchemasIntervalFormsItemFormKey :: !(Maybe Text) -- ^ "formKey" - Form key scheduled in the interval
  , componentsSchemasIntervalFormsItemFormName :: !(Maybe Text) -- ^ "formName" - Form name scheduled in the interval
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComponentsSchemasIntervalFormsItem
instance A.FromJSON ComponentsSchemasIntervalFormsItem where
  parseJSON = A.withObject "ComponentsSchemasIntervalFormsItem" $ \o ->
    ComponentsSchemasIntervalFormsItem
      <$> (o .:? "formId")
      <*> (o .:? "formKey")
      <*> (o .:? "formName")

-- | ToJSON ComponentsSchemasIntervalFormsItem
instance A.ToJSON ComponentsSchemasIntervalFormsItem where
  toJSON ComponentsSchemasIntervalFormsItem {..} =
   _omitNulls
      [ "formId" .= componentsSchemasIntervalFormsItemFormId
      , "formKey" .= componentsSchemasIntervalFormsItemFormKey
      , "formName" .= componentsSchemasIntervalFormsItemFormName
      ]


-- | Construct a value of type 'ComponentsSchemasIntervalFormsItem' (by applying it's required fields, if any)
mkComponentsSchemasIntervalFormsItem
  :: ComponentsSchemasIntervalFormsItem
mkComponentsSchemasIntervalFormsItem =
  ComponentsSchemasIntervalFormsItem
  { componentsSchemasIntervalFormsItemFormId = Nothing
  , componentsSchemasIntervalFormsItemFormKey = Nothing
  , componentsSchemasIntervalFormsItemFormName = Nothing
  }

-- ** ComponentsSchemasMetadataError
-- | ComponentsSchemasMetadataError
-- components_schemas_Metadata_error
-- 
-- Error details if an error occurred
data ComponentsSchemasMetadataError = ComponentsSchemasMetadataError
  { componentsSchemasMetadataErrorMessage :: !(Maybe Text) -- ^ "message" - Error message describing the issue
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComponentsSchemasMetadataError
instance A.FromJSON ComponentsSchemasMetadataError where
  parseJSON = A.withObject "ComponentsSchemasMetadataError" $ \o ->
    ComponentsSchemasMetadataError
      <$> (o .:? "message")

-- | ToJSON ComponentsSchemasMetadataError
instance A.ToJSON ComponentsSchemasMetadataError where
  toJSON ComponentsSchemasMetadataError {..} =
   _omitNulls
      [ "message" .= componentsSchemasMetadataErrorMessage
      ]


-- | Construct a value of type 'ComponentsSchemasMetadataError' (by applying it's required fields, if any)
mkComponentsSchemasMetadataError
  :: ComponentsSchemasMetadataError
mkComponentsSchemasMetadataError =
  ComponentsSchemasMetadataError
  { componentsSchemasMetadataErrorMessage = Nothing
  }

-- ** ComponentsSchemasRecordCreateRequestItem
-- | ComponentsSchemasRecordCreateRequestItem
-- components_schemas_RecordCreateRequest_item
-- 
data ComponentsSchemasRecordCreateRequestItem = ComponentsSchemasRecordCreateRequestItem
  { componentsSchemasRecordCreateRequestItemFormKey :: !(Text) -- ^ /Required/ "formKey" - Form key identifying the eCRF to create or update
  , componentsSchemasRecordCreateRequestItemFormId :: !(Maybe Int) -- ^ "formId" - Form ID identifying the eCRF to create or update (alternative to formKey)
  , componentsSchemasRecordCreateRequestItemSiteName :: !(Maybe Text) -- ^ "siteName" - Name of the site where the record should be created (for new subject registration)
  , componentsSchemasRecordCreateRequestItemSiteId :: !(Maybe Int) -- ^ "siteId" - Site ID for the record (alternative to siteName)
  , componentsSchemasRecordCreateRequestItemSubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Subject identifier (display ID) for which to create or update the record
  , componentsSchemasRecordCreateRequestItemSubjectId :: !(Maybe Int) -- ^ "subjectId" - Subject ID for which to create or update the record (alternative to subjectKey)
  , componentsSchemasRecordCreateRequestItemSubjectOid :: !(Maybe Text) -- ^ "subjectOid" - Subject OID for which to create or update the record (alternative to subjectKey)
  , componentsSchemasRecordCreateRequestItemIntervalName :: !(Maybe Text) -- ^ "intervalName" - Name of the interval (visit) for a scheduled record update
  , componentsSchemasRecordCreateRequestItemIntervalId :: !(Maybe Int) -- ^ "intervalId" - Interval ID for a scheduled record update (alternative to intervalName)
  , componentsSchemasRecordCreateRequestItemRecordId :: !(Maybe Int) -- ^ "recordId" - Record ID for updating an existing unscheduled record (if applicable)
  , componentsSchemasRecordCreateRequestItemRecordOid :: !(Maybe Text) -- ^ "recordOid" - Record OID for updating an existing unscheduled record (if applicable)
  , componentsSchemasRecordCreateRequestItemData :: !((Map.Map String AnyType)) -- ^ /Required/ "data" - Key-value pairs of field names and values for the record data
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComponentsSchemasRecordCreateRequestItem
instance A.FromJSON ComponentsSchemasRecordCreateRequestItem where
  parseJSON = A.withObject "ComponentsSchemasRecordCreateRequestItem" $ \o ->
    ComponentsSchemasRecordCreateRequestItem
      <$> (o .:  "formKey")
      <*> (o .:? "formId")
      <*> (o .:? "siteName")
      <*> (o .:? "siteId")
      <*> (o .:? "subjectKey")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectOid")
      <*> (o .:? "intervalName")
      <*> (o .:? "intervalId")
      <*> (o .:? "recordId")
      <*> (o .:? "recordOid")
      <*> (o .:  "data")

-- | ToJSON ComponentsSchemasRecordCreateRequestItem
instance A.ToJSON ComponentsSchemasRecordCreateRequestItem where
  toJSON ComponentsSchemasRecordCreateRequestItem {..} =
   _omitNulls
      [ "formKey" .= componentsSchemasRecordCreateRequestItemFormKey
      , "formId" .= componentsSchemasRecordCreateRequestItemFormId
      , "siteName" .= componentsSchemasRecordCreateRequestItemSiteName
      , "siteId" .= componentsSchemasRecordCreateRequestItemSiteId
      , "subjectKey" .= componentsSchemasRecordCreateRequestItemSubjectKey
      , "subjectId" .= componentsSchemasRecordCreateRequestItemSubjectId
      , "subjectOid" .= componentsSchemasRecordCreateRequestItemSubjectOid
      , "intervalName" .= componentsSchemasRecordCreateRequestItemIntervalName
      , "intervalId" .= componentsSchemasRecordCreateRequestItemIntervalId
      , "recordId" .= componentsSchemasRecordCreateRequestItemRecordId
      , "recordOid" .= componentsSchemasRecordCreateRequestItemRecordOid
      , "data" .= componentsSchemasRecordCreateRequestItemData
      ]


-- | Construct a value of type 'ComponentsSchemasRecordCreateRequestItem' (by applying it's required fields, if any)
mkComponentsSchemasRecordCreateRequestItem
  :: Text -- ^ 'componentsSchemasRecordCreateRequestItemFormKey': Form key identifying the eCRF to create or update
  -> (Map.Map String AnyType) -- ^ 'componentsSchemasRecordCreateRequestItemData': Key-value pairs of field names and values for the record data
  -> ComponentsSchemasRecordCreateRequestItem
mkComponentsSchemasRecordCreateRequestItem componentsSchemasRecordCreateRequestItemFormKey componentsSchemasRecordCreateRequestItemData =
  ComponentsSchemasRecordCreateRequestItem
  { componentsSchemasRecordCreateRequestItemFormKey
  , componentsSchemasRecordCreateRequestItemFormId = Nothing
  , componentsSchemasRecordCreateRequestItemSiteName = Nothing
  , componentsSchemasRecordCreateRequestItemSiteId = Nothing
  , componentsSchemasRecordCreateRequestItemSubjectKey = Nothing
  , componentsSchemasRecordCreateRequestItemSubjectId = Nothing
  , componentsSchemasRecordCreateRequestItemSubjectOid = Nothing
  , componentsSchemasRecordCreateRequestItemIntervalName = Nothing
  , componentsSchemasRecordCreateRequestItemIntervalId = Nothing
  , componentsSchemasRecordCreateRequestItemRecordId = Nothing
  , componentsSchemasRecordCreateRequestItemRecordOid = Nothing
  , componentsSchemasRecordCreateRequestItemData
  }

-- ** Form
-- | Form
-- Form
-- 
data Form = Form
  { formStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , formFormId :: !(Maybe Int) -- ^ "formId" - Mednet Form ID
  , formFormKey :: !(Maybe Text) -- ^ "formKey" - User-defined form key
  , formFormName :: !(Maybe Text) -- ^ "formName" - Name of the form (eCRF)
  , formFormType :: !(Maybe Text) -- ^ "formType" - Type of the form (e.g., Subject or Site)
  , formRevision :: !(Maybe Int) -- ^ "revision" - Number of modifications (revisions) of the form metadata
  , formEmbeddedLog :: !(Maybe Bool) -- ^ "embeddedLog" - Whether the form has an embedded log
  , formEnforceOwnership :: !(Maybe Bool) -- ^ "enforceOwnership" - Whether the form enforces record ownership
  , formUserAgreement :: !(Maybe Bool) -- ^ "userAgreement" - Whether the form requires a user agreement
  , formSubjectRecordReport :: !(Maybe Bool) -- ^ "subjectRecordReport" - Whether the form is marked as a subject record report
  , formUnscheduledVisit :: !(Maybe Bool) -- ^ "unscheduledVisit" - Whether the form is included in unscheduled visits
  , formOtherForms :: !(Maybe Bool) -- ^ "otherForms" - Whether the form is included in Other Forms category
  , formEproForm :: !(Maybe Bool) -- ^ "eproForm" - Whether the form is an ePRO (electronic patient reported outcome) form
  , formAllowCopy :: !(Maybe Bool) -- ^ "allowCopy" - Whether the form allows copying of data
  , formDisabled :: !(Maybe Bool) -- ^ "disabled" - Whether the form is soft-deleted (disabled)
  , formDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this form was created
  , formDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this form was last modified
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Form
instance A.FromJSON Form where
  parseJSON = A.withObject "Form" $ \o ->
    Form
      <$> (o .:? "studyKey")
      <*> (o .:? "formId")
      <*> (o .:? "formKey")
      <*> (o .:? "formName")
      <*> (o .:? "formType")
      <*> (o .:? "revision")
      <*> (o .:? "embeddedLog")
      <*> (o .:? "enforceOwnership")
      <*> (o .:? "userAgreement")
      <*> (o .:? "subjectRecordReport")
      <*> (o .:? "unscheduledVisit")
      <*> (o .:? "otherForms")
      <*> (o .:? "eproForm")
      <*> (o .:? "allowCopy")
      <*> (o .:? "disabled")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")

-- | ToJSON Form
instance A.ToJSON Form where
  toJSON Form {..} =
   _omitNulls
      [ "studyKey" .= formStudyKey
      , "formId" .= formFormId
      , "formKey" .= formFormKey
      , "formName" .= formFormName
      , "formType" .= formFormType
      , "revision" .= formRevision
      , "embeddedLog" .= formEmbeddedLog
      , "enforceOwnership" .= formEnforceOwnership
      , "userAgreement" .= formUserAgreement
      , "subjectRecordReport" .= formSubjectRecordReport
      , "unscheduledVisit" .= formUnscheduledVisit
      , "otherForms" .= formOtherForms
      , "eproForm" .= formEproForm
      , "allowCopy" .= formAllowCopy
      , "disabled" .= formDisabled
      , "dateCreated" .= formDateCreated
      , "dateModified" .= formDateModified
      ]


-- | Construct a value of type 'Form' (by applying it's required fields, if any)
mkForm
  :: Form
mkForm =
  Form
  { formStudyKey = Nothing
  , formFormId = Nothing
  , formFormKey = Nothing
  , formFormName = Nothing
  , formFormType = Nothing
  , formRevision = Nothing
  , formEmbeddedLog = Nothing
  , formEnforceOwnership = Nothing
  , formUserAgreement = Nothing
  , formSubjectRecordReport = Nothing
  , formUnscheduledVisit = Nothing
  , formOtherForms = Nothing
  , formEproForm = Nothing
  , formAllowCopy = Nothing
  , formDisabled = Nothing
  , formDateCreated = Nothing
  , formDateModified = Nothing
  }

-- ** FormList
-- | FormList
-- FormList
-- 
data FormList = FormList
  { formListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , formListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , formListData :: !(Maybe [Form]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FormList
instance A.FromJSON FormList where
  parseJSON = A.withObject "FormList" $ \o ->
    FormList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON FormList
instance A.ToJSON FormList where
  toJSON FormList {..} =
   _omitNulls
      [ "metadata" .= formListMetadata
      , "pagination" .= formListPagination
      , "data" .= formListData
      ]


-- | Construct a value of type 'FormList' (by applying it's required fields, if any)
mkFormList
  :: FormList
mkFormList =
  FormList
  { formListMetadata = Nothing
  , formListPagination = Nothing
  , formListData = Nothing
  }

-- ** InlineObject
-- | InlineObject
data InlineObject = InlineObject
  { inlineObjectMetadata :: !(Maybe Metadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:? "metadata")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "metadata" .= inlineObjectMetadata
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: InlineObject
mkInlineObject =
  InlineObject
  { inlineObjectMetadata = Nothing
  }

-- ** InlineObject1
-- | InlineObject1
data InlineObject1 = InlineObject1
  { inlineObject1Metadata :: !(Maybe Metadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:? "metadata")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
   _omitNulls
      [ "metadata" .= inlineObject1Metadata
      ]


-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1
  :: InlineObject1
mkInlineObject1 =
  InlineObject1
  { inlineObject1Metadata = Nothing
  }

-- ** InlineObject2
-- | InlineObject2
data InlineObject2 = InlineObject2
  { inlineObject2Metadata :: !(Maybe Metadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject2
instance A.FromJSON InlineObject2 where
  parseJSON = A.withObject "InlineObject2" $ \o ->
    InlineObject2
      <$> (o .:? "metadata")

-- | ToJSON InlineObject2
instance A.ToJSON InlineObject2 where
  toJSON InlineObject2 {..} =
   _omitNulls
      [ "metadata" .= inlineObject2Metadata
      ]


-- | Construct a value of type 'InlineObject2' (by applying it's required fields, if any)
mkInlineObject2
  :: InlineObject2
mkInlineObject2 =
  InlineObject2
  { inlineObject2Metadata = Nothing
  }

-- ** InlineObject3
-- | InlineObject3
data InlineObject3 = InlineObject3
  { inlineObject3Metadata :: !(Maybe Metadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject3
instance A.FromJSON InlineObject3 where
  parseJSON = A.withObject "InlineObject3" $ \o ->
    InlineObject3
      <$> (o .:? "metadata")

-- | ToJSON InlineObject3
instance A.ToJSON InlineObject3 where
  toJSON InlineObject3 {..} =
   _omitNulls
      [ "metadata" .= inlineObject3Metadata
      ]


-- | Construct a value of type 'InlineObject3' (by applying it's required fields, if any)
mkInlineObject3
  :: InlineObject3
mkInlineObject3 =
  InlineObject3
  { inlineObject3Metadata = Nothing
  }

-- ** InlineObject4
-- | InlineObject4
data InlineObject4 = InlineObject4
  { inlineObject4Metadata :: !(Maybe Metadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject4
instance A.FromJSON InlineObject4 where
  parseJSON = A.withObject "InlineObject4" $ \o ->
    InlineObject4
      <$> (o .:? "metadata")

-- | ToJSON InlineObject4
instance A.ToJSON InlineObject4 where
  toJSON InlineObject4 {..} =
   _omitNulls
      [ "metadata" .= inlineObject4Metadata
      ]


-- | Construct a value of type 'InlineObject4' (by applying it's required fields, if any)
mkInlineObject4
  :: InlineObject4
mkInlineObject4 =
  InlineObject4
  { inlineObject4Metadata = Nothing
  }

-- ** InlineObject5
-- | InlineObject5
data InlineObject5 = InlineObject5
  { inlineObject5Metadata :: !(Maybe Metadata) -- ^ "metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject5
instance A.FromJSON InlineObject5 where
  parseJSON = A.withObject "InlineObject5" $ \o ->
    InlineObject5
      <$> (o .:? "metadata")

-- | ToJSON InlineObject5
instance A.ToJSON InlineObject5 where
  toJSON InlineObject5 {..} =
   _omitNulls
      [ "metadata" .= inlineObject5Metadata
      ]


-- | Construct a value of type 'InlineObject5' (by applying it's required fields, if any)
mkInlineObject5
  :: InlineObject5
mkInlineObject5 =
  InlineObject5
  { inlineObject5Metadata = Nothing
  }

-- ** Interval
-- | Interval
-- Interval
-- 
data Interval = Interval
  { intervalStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , intervalIntervalId :: !(Maybe Int) -- ^ "intervalId" - Unique system identifier for the interval (visit definition)
  , intervalIntervalName :: !(Maybe Text) -- ^ "intervalName" - Name of the interval (visit) as defined in the study
  , intervalIntervalDescription :: !(Maybe Text) -- ^ "intervalDescription" - Description of the interval (visit)
  , intervalIntervalSequence :: !(Maybe Int) -- ^ "intervalSequence" - Sequence number of the interval in the schedule
  , intervalIntervalGroupId :: !(Maybe Int) -- ^ "intervalGroupId" - Identifier for the interval group (if intervals are grouped)
  , intervalIntervalGroupName :: !(Maybe Text) -- ^ "intervalGroupName" - Name of the interval group
  , intervalTimeline :: !(Maybe Text) -- ^ "timeline" - Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)
  , intervalDefinedUsingInterval :: !(Maybe Text) -- ^ "definedUsingInterval" - Baseline interval used for calculating this intervalâ€™s dates
  , intervalWindowCalculationForm :: !(Maybe Text) -- ^ "windowCalculationForm" - Baseline form (name) from which the calculation date is taken
  , intervalWindowCalculationDate :: !(Maybe Text) -- ^ "windowCalculationDate" - Baseline field (variable name) from which the calculation date is taken
  , intervalActualDateForm :: !(Maybe Text) -- ^ "actualDateForm" - Form used to capture the actual date for this interval
  , intervalActualDate :: !(Maybe Text) -- ^ "actualDate" - Field (variable name) used to capture the actual date for this interval
  , intervalDueDateWillBeIn :: !(Maybe Int) -- ^ "dueDateWillBeIn" - Number of days from the calculation date when the interval is due
  , intervalNegativeSlack :: !(Maybe Int) -- ^ "negativeSlack" - Number of days before the due date that are allowed (negative window)
  , intervalPositiveSlack :: !(Maybe Int) -- ^ "positiveSlack" - Number of days after the due date that are allowed (positive window)
  , intervalEproGracePeriod :: !(Maybe Int) -- ^ "eproGracePeriod" - Number of days of grace period for ePRO completion after due date
  , intervalForms :: !(Maybe [ComponentsSchemasIntervalFormsItem]) -- ^ "forms" - List of forms that are scheduled in this interval
  , intervalDisabled :: !(Maybe Bool) -- ^ "disabled" - Whether the interval is soft-deleted (disabled)
  , intervalDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this interval was created
  , intervalDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this interval was last modified
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Interval
instance A.FromJSON Interval where
  parseJSON = A.withObject "Interval" $ \o ->
    Interval
      <$> (o .:? "studyKey")
      <*> (o .:? "intervalId")
      <*> (o .:? "intervalName")
      <*> (o .:? "intervalDescription")
      <*> (o .:? "intervalSequence")
      <*> (o .:? "intervalGroupId")
      <*> (o .:? "intervalGroupName")
      <*> (o .:? "timeline")
      <*> (o .:? "definedUsingInterval")
      <*> (o .:? "windowCalculationForm")
      <*> (o .:? "windowCalculationDate")
      <*> (o .:? "actualDateForm")
      <*> (o .:? "actualDate")
      <*> (o .:? "dueDateWillBeIn")
      <*> (o .:? "negativeSlack")
      <*> (o .:? "positiveSlack")
      <*> (o .:? "eproGracePeriod")
      <*> (o .:? "forms")
      <*> (o .:? "disabled")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")

-- | ToJSON Interval
instance A.ToJSON Interval where
  toJSON Interval {..} =
   _omitNulls
      [ "studyKey" .= intervalStudyKey
      , "intervalId" .= intervalIntervalId
      , "intervalName" .= intervalIntervalName
      , "intervalDescription" .= intervalIntervalDescription
      , "intervalSequence" .= intervalIntervalSequence
      , "intervalGroupId" .= intervalIntervalGroupId
      , "intervalGroupName" .= intervalIntervalGroupName
      , "timeline" .= intervalTimeline
      , "definedUsingInterval" .= intervalDefinedUsingInterval
      , "windowCalculationForm" .= intervalWindowCalculationForm
      , "windowCalculationDate" .= intervalWindowCalculationDate
      , "actualDateForm" .= intervalActualDateForm
      , "actualDate" .= intervalActualDate
      , "dueDateWillBeIn" .= intervalDueDateWillBeIn
      , "negativeSlack" .= intervalNegativeSlack
      , "positiveSlack" .= intervalPositiveSlack
      , "eproGracePeriod" .= intervalEproGracePeriod
      , "forms" .= intervalForms
      , "disabled" .= intervalDisabled
      , "dateCreated" .= intervalDateCreated
      , "dateModified" .= intervalDateModified
      ]


-- | Construct a value of type 'Interval' (by applying it's required fields, if any)
mkInterval
  :: Interval
mkInterval =
  Interval
  { intervalStudyKey = Nothing
  , intervalIntervalId = Nothing
  , intervalIntervalName = Nothing
  , intervalIntervalDescription = Nothing
  , intervalIntervalSequence = Nothing
  , intervalIntervalGroupId = Nothing
  , intervalIntervalGroupName = Nothing
  , intervalTimeline = Nothing
  , intervalDefinedUsingInterval = Nothing
  , intervalWindowCalculationForm = Nothing
  , intervalWindowCalculationDate = Nothing
  , intervalActualDateForm = Nothing
  , intervalActualDate = Nothing
  , intervalDueDateWillBeIn = Nothing
  , intervalNegativeSlack = Nothing
  , intervalPositiveSlack = Nothing
  , intervalEproGracePeriod = Nothing
  , intervalForms = Nothing
  , intervalDisabled = Nothing
  , intervalDateCreated = Nothing
  , intervalDateModified = Nothing
  }

-- ** IntervalList
-- | IntervalList
-- IntervalList
-- 
data IntervalList = IntervalList
  { intervalListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , intervalListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , intervalListData :: !(Maybe [Interval]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IntervalList
instance A.FromJSON IntervalList where
  parseJSON = A.withObject "IntervalList" $ \o ->
    IntervalList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON IntervalList
instance A.ToJSON IntervalList where
  toJSON IntervalList {..} =
   _omitNulls
      [ "metadata" .= intervalListMetadata
      , "pagination" .= intervalListPagination
      , "data" .= intervalListData
      ]


-- | Construct a value of type 'IntervalList' (by applying it's required fields, if any)
mkIntervalList
  :: IntervalList
mkIntervalList =
  IntervalList
  { intervalListMetadata = Nothing
  , intervalListPagination = Nothing
  , intervalListData = Nothing
  }

-- ** Job
-- | Job
-- Job
-- 
data Job = Job
  { jobJobId :: !(Maybe Text) -- ^ "jobId" - Unique job identifier
  , jobBatchId :: !(Maybe Text) -- ^ "batchId" - Batch ID associated with the job (useful for linking with record creation requests)
  , jobState :: !(Maybe Text) -- ^ "state" - State of the job (e.g., completed, pending)
  , jobDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Timestamp when the job was created
  , jobDateStarted :: !(Maybe Text) -- ^ "dateStarted" - Timestamp when the job started processing
  , jobDateFinished :: !(Maybe Text) -- ^ "dateFinished" - Timestamp when the job finished processing
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Job
instance A.FromJSON Job where
  parseJSON = A.withObject "Job" $ \o ->
    Job
      <$> (o .:? "jobId")
      <*> (o .:? "batchId")
      <*> (o .:? "state")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateStarted")
      <*> (o .:? "dateFinished")

-- | ToJSON Job
instance A.ToJSON Job where
  toJSON Job {..} =
   _omitNulls
      [ "jobId" .= jobJobId
      , "batchId" .= jobBatchId
      , "state" .= jobState
      , "dateCreated" .= jobDateCreated
      , "dateStarted" .= jobDateStarted
      , "dateFinished" .= jobDateFinished
      ]


-- | Construct a value of type 'Job' (by applying it's required fields, if any)
mkJob
  :: Job
mkJob =
  Job
  { jobJobId = Nothing
  , jobBatchId = Nothing
  , jobState = Nothing
  , jobDateCreated = Nothing
  , jobDateStarted = Nothing
  , jobDateFinished = Nothing
  }

-- ** Keyword
-- | Keyword
-- Keyword
-- 
data Keyword = Keyword
  { keywordKeywordName :: !(Maybe Text) -- ^ "keywordName" - Name of the keyword
  , keywordKeywordKey :: !(Maybe Text) -- ^ "keywordKey" - Key of the keyword (short code)
  , keywordKeywordId :: !(Maybe Int) -- ^ "keywordId" - Internal keyword ID
  , keywordDateAdded :: !(Maybe Text) -- ^ "dateAdded" - Date when this keyword was added
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Keyword
instance A.FromJSON Keyword where
  parseJSON = A.withObject "Keyword" $ \o ->
    Keyword
      <$> (o .:? "keywordName")
      <*> (o .:? "keywordKey")
      <*> (o .:? "keywordId")
      <*> (o .:? "dateAdded")

-- | ToJSON Keyword
instance A.ToJSON Keyword where
  toJSON Keyword {..} =
   _omitNulls
      [ "keywordName" .= keywordKeywordName
      , "keywordKey" .= keywordKeywordKey
      , "keywordId" .= keywordKeywordId
      , "dateAdded" .= keywordDateAdded
      ]


-- | Construct a value of type 'Keyword' (by applying it's required fields, if any)
mkKeyword
  :: Keyword
mkKeyword =
  Keyword
  { keywordKeywordName = Nothing
  , keywordKeywordKey = Nothing
  , keywordKeywordId = Nothing
  , keywordDateAdded = Nothing
  }

-- ** Metadata
-- | Metadata
-- Metadata
-- 
data Metadata = Metadata
  { metadataStatus :: !(Maybe Text) -- ^ "status" - HTTP status of the response (e.g., OK or ERROR)
  , metadataMethod :: !(Maybe Text) -- ^ "method" - HTTP method of the request
  , metadataPath :: !(Maybe Text) -- ^ "path" - Requested URI path
  , metadataTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - Timestamp when response was generated
  , metadataError :: !(Maybe ComponentsSchemasMetadataError) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Metadata
instance A.FromJSON Metadata where
  parseJSON = A.withObject "Metadata" $ \o ->
    Metadata
      <$> (o .:? "status")
      <*> (o .:? "method")
      <*> (o .:? "path")
      <*> (o .:? "timestamp")
      <*> (o .:? "error")

-- | ToJSON Metadata
instance A.ToJSON Metadata where
  toJSON Metadata {..} =
   _omitNulls
      [ "status" .= metadataStatus
      , "method" .= metadataMethod
      , "path" .= metadataPath
      , "timestamp" .= metadataTimestamp
      , "error" .= metadataError
      ]


-- | Construct a value of type 'Metadata' (by applying it's required fields, if any)
mkMetadata
  :: Metadata
mkMetadata =
  Metadata
  { metadataStatus = Nothing
  , metadataMethod = Nothing
  , metadataPath = Nothing
  , metadataTimestamp = Nothing
  , metadataError = Nothing
  }

-- ** Pagination
-- | Pagination
-- Pagination
-- 
data Pagination = Pagination
  { paginationCurrentPage :: !(Maybe Int) -- ^ "currentPage" - Current index page returned
  , paginationSize :: !(Maybe Int) -- ^ "size" - Number of items per page returned
  , paginationTotalPages :: !(Maybe Int) -- ^ "totalPages" - Total number of pages available
  , paginationTotalElements :: !(Maybe Int) -- ^ "totalElements" - Total number of elements (items) available
  , paginationSort :: !(Maybe [Sort]) -- ^ "sort"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Pagination
instance A.FromJSON Pagination where
  parseJSON = A.withObject "Pagination" $ \o ->
    Pagination
      <$> (o .:? "currentPage")
      <*> (o .:? "size")
      <*> (o .:? "totalPages")
      <*> (o .:? "totalElements")
      <*> (o .:? "sort")

-- | ToJSON Pagination
instance A.ToJSON Pagination where
  toJSON Pagination {..} =
   _omitNulls
      [ "currentPage" .= paginationCurrentPage
      , "size" .= paginationSize
      , "totalPages" .= paginationTotalPages
      , "totalElements" .= paginationTotalElements
      , "sort" .= paginationSort
      ]


-- | Construct a value of type 'Pagination' (by applying it's required fields, if any)
mkPagination
  :: Pagination
mkPagination =
  Pagination
  { paginationCurrentPage = Nothing
  , paginationSize = Nothing
  , paginationTotalPages = Nothing
  , paginationTotalElements = Nothing
  , paginationSort = Nothing
  }

-- ** Query
-- | Query
-- Query
-- 
data Query = Query
  { queryStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , querySubjectId :: !(Maybe Int) -- ^ "subjectId" - Mednet subject ID associated with the query (if applicable)
  , querySubjectOid :: !(Maybe Text) -- ^ "subjectOid" - Client-assigned subject OID (if applicable)
  , queryAnnotationType :: !(Maybe Text) -- ^ "annotationType" - Category/type of the query (e.g., subject, record, question)
  , queryAnnotationId :: !(Maybe Int) -- ^ "annotationId" - Unique system identifier for the query
  , queryType :: !(Maybe Text) -- ^ "type" - System text identifier for the query type/location (subject, record, question)
  , queryDescription :: !(Maybe Text) -- ^ "description" - Description of the query (e.g., reason or context)
  , queryRecordId :: !(Maybe Int) -- ^ "recordId" - Record ID associated with the query (if applicable)
  , queryVariable :: !(Maybe Text) -- ^ "variable" - Variable name (field) associated with the query (if applicable)
  , querySubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Subject display ID associated with the query (if applicable)
  , queryDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when the query was created
  , queryDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when the query was last modified
  , queryQueryComments :: !(Maybe [QueryComment]) -- ^ "queryComments" - History of comments/actions on the query
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Query
instance A.FromJSON Query where
  parseJSON = A.withObject "Query" $ \o ->
    Query
      <$> (o .:? "studyKey")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectOid")
      <*> (o .:? "annotationType")
      <*> (o .:? "annotationId")
      <*> (o .:? "type")
      <*> (o .:? "description")
      <*> (o .:? "recordId")
      <*> (o .:? "variable")
      <*> (o .:? "subjectKey")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")
      <*> (o .:? "queryComments")

-- | ToJSON Query
instance A.ToJSON Query where
  toJSON Query {..} =
   _omitNulls
      [ "studyKey" .= queryStudyKey
      , "subjectId" .= querySubjectId
      , "subjectOid" .= querySubjectOid
      , "annotationType" .= queryAnnotationType
      , "annotationId" .= queryAnnotationId
      , "type" .= queryType
      , "description" .= queryDescription
      , "recordId" .= queryRecordId
      , "variable" .= queryVariable
      , "subjectKey" .= querySubjectKey
      , "dateCreated" .= queryDateCreated
      , "dateModified" .= queryDateModified
      , "queryComments" .= queryQueryComments
      ]


-- | Construct a value of type 'Query' (by applying it's required fields, if any)
mkQuery
  :: Query
mkQuery =
  Query
  { queryStudyKey = Nothing
  , querySubjectId = Nothing
  , querySubjectOid = Nothing
  , queryAnnotationType = Nothing
  , queryAnnotationId = Nothing
  , queryType = Nothing
  , queryDescription = Nothing
  , queryRecordId = Nothing
  , queryVariable = Nothing
  , querySubjectKey = Nothing
  , queryDateCreated = Nothing
  , queryDateModified = Nothing
  , queryQueryComments = Nothing
  }

-- ** QueryComment
-- | QueryComment
-- QueryComment
-- 
data QueryComment = QueryComment
  { queryCommentSequence :: !(Maybe Int) -- ^ "sequence" - Sequence number of the comment/action in the query history
  , queryCommentAnnotationStatus :: !(Maybe Text) -- ^ "annotationStatus" - Status of the query after this comment (e.g., Open, Closed)
  , queryCommentUser :: !(Maybe Text) -- ^ "user" - Username of the user who made the comment or action
  , queryCommentComment :: !(Maybe Text) -- ^ "comment" - Text of the comment
  , queryCommentClosed :: !(Maybe Bool) -- ^ "closed" - Whether the query was marked closed at this step
  , queryCommentDate :: !(Maybe Text) -- ^ "date" - Date of the comment or action
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueryComment
instance A.FromJSON QueryComment where
  parseJSON = A.withObject "QueryComment" $ \o ->
    QueryComment
      <$> (o .:? "sequence")
      <*> (o .:? "annotationStatus")
      <*> (o .:? "user")
      <*> (o .:? "comment")
      <*> (o .:? "closed")
      <*> (o .:? "date")

-- | ToJSON QueryComment
instance A.ToJSON QueryComment where
  toJSON QueryComment {..} =
   _omitNulls
      [ "sequence" .= queryCommentSequence
      , "annotationStatus" .= queryCommentAnnotationStatus
      , "user" .= queryCommentUser
      , "comment" .= queryCommentComment
      , "closed" .= queryCommentClosed
      , "date" .= queryCommentDate
      ]


-- | Construct a value of type 'QueryComment' (by applying it's required fields, if any)
mkQueryComment
  :: QueryComment
mkQueryComment =
  QueryComment
  { queryCommentSequence = Nothing
  , queryCommentAnnotationStatus = Nothing
  , queryCommentUser = Nothing
  , queryCommentComment = Nothing
  , queryCommentClosed = Nothing
  , queryCommentDate = Nothing
  }

-- ** QueryList
-- | QueryList
-- QueryList
-- 
data QueryList = QueryList
  { queryListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , queryListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , queryListData :: !(Maybe [Query]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueryList
instance A.FromJSON QueryList where
  parseJSON = A.withObject "QueryList" $ \o ->
    QueryList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON QueryList
instance A.ToJSON QueryList where
  toJSON QueryList {..} =
   _omitNulls
      [ "metadata" .= queryListMetadata
      , "pagination" .= queryListPagination
      , "data" .= queryListData
      ]


-- | Construct a value of type 'QueryList' (by applying it's required fields, if any)
mkQueryList
  :: QueryList
mkQueryList =
  QueryList
  { queryListMetadata = Nothing
  , queryListPagination = Nothing
  , queryListData = Nothing
  }

-- ** Record
-- | Record
-- Record
-- 
data Record = Record
  { recordStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , recordIntervalId :: !(Maybe Int) -- ^ "intervalId" - Interval ID (visit definition) that this record is associated with
  , recordFormId :: !(Maybe Int) -- ^ "formId" - Form ID of the form this record instance belongs to
  , recordFormKey :: !(Maybe Text) -- ^ "formKey" - Form key of the form for this record instance
  , recordSiteId :: !(Maybe Int) -- ^ "siteId" - Site ID associated with the record
  , recordRecordId :: !(Maybe Int) -- ^ "recordId" - Unique record ID
  , recordRecordOid :: !(Maybe Text) -- ^ "recordOid" - Client-assigned record OID
  , recordRecordType :: !(Maybe Text) -- ^ "recordType" - Type of record (e.g., SUBJECT for subject-related forms)
  , recordRecordStatus :: !(Maybe Text) -- ^ "recordStatus" - Current status of the record (e.g., Record Incomplete, Record Complete)
  , recordDeleted :: !(Maybe Bool) -- ^ "deleted" - Whether the record is marked as deleted
  , recordDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this record was created
  , recordDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this record was last modified
  , recordSubjectId :: !(Maybe Int) -- ^ "subjectId" - Mednet subject ID that this record is associated with
  , recordSubjectOid :: !(Maybe Text) -- ^ "subjectOid" - Client-assigned subject OID for the subject this record is associated with
  , recordSubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Subject display ID that this record is associated with
  , recordVisitId :: !(Maybe Int) -- ^ "visitId" - Visit instance ID that this record is associated with (if applicable)
  , recordParentRecordId :: !(Maybe Int) -- ^ "parentRecordId" - Record ID of the parent record if this record is a subrecord (if applicable)
  , recordKeywords :: !(Maybe [Keyword]) -- ^ "keywords" - List of keywords associated with the record
  , recordRecordData :: !(Maybe (Map.Map String AnyType)) -- ^ "recordData" - Data fields and values captured in this record. The structure is dynamic, with keys corresponding to variable names.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Record
instance A.FromJSON Record where
  parseJSON = A.withObject "Record" $ \o ->
    Record
      <$> (o .:? "studyKey")
      <*> (o .:? "intervalId")
      <*> (o .:? "formId")
      <*> (o .:? "formKey")
      <*> (o .:? "siteId")
      <*> (o .:? "recordId")
      <*> (o .:? "recordOid")
      <*> (o .:? "recordType")
      <*> (o .:? "recordStatus")
      <*> (o .:? "deleted")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectOid")
      <*> (o .:? "subjectKey")
      <*> (o .:? "visitId")
      <*> (o .:? "parentRecordId")
      <*> (o .:? "keywords")
      <*> (o .:? "recordData")

-- | ToJSON Record
instance A.ToJSON Record where
  toJSON Record {..} =
   _omitNulls
      [ "studyKey" .= recordStudyKey
      , "intervalId" .= recordIntervalId
      , "formId" .= recordFormId
      , "formKey" .= recordFormKey
      , "siteId" .= recordSiteId
      , "recordId" .= recordRecordId
      , "recordOid" .= recordRecordOid
      , "recordType" .= recordRecordType
      , "recordStatus" .= recordRecordStatus
      , "deleted" .= recordDeleted
      , "dateCreated" .= recordDateCreated
      , "dateModified" .= recordDateModified
      , "subjectId" .= recordSubjectId
      , "subjectOid" .= recordSubjectOid
      , "subjectKey" .= recordSubjectKey
      , "visitId" .= recordVisitId
      , "parentRecordId" .= recordParentRecordId
      , "keywords" .= recordKeywords
      , "recordData" .= recordRecordData
      ]


-- | Construct a value of type 'Record' (by applying it's required fields, if any)
mkRecord
  :: Record
mkRecord =
  Record
  { recordStudyKey = Nothing
  , recordIntervalId = Nothing
  , recordFormId = Nothing
  , recordFormKey = Nothing
  , recordSiteId = Nothing
  , recordRecordId = Nothing
  , recordRecordOid = Nothing
  , recordRecordType = Nothing
  , recordRecordStatus = Nothing
  , recordDeleted = Nothing
  , recordDateCreated = Nothing
  , recordDateModified = Nothing
  , recordSubjectId = Nothing
  , recordSubjectOid = Nothing
  , recordSubjectKey = Nothing
  , recordVisitId = Nothing
  , recordParentRecordId = Nothing
  , recordKeywords = Nothing
  , recordRecordData = Nothing
  }

-- ** RecordJobStatus
-- | RecordJobStatus
-- RecordJobStatus
-- 
data RecordJobStatus = RecordJobStatus
  { recordJobStatusJobId :: !(Maybe Text) -- ^ "jobId" - Unique job identifier
  , recordJobStatusBatchId :: !(Maybe Text) -- ^ "batchId" - Batch ID used to track the job (identical to jobId in most cases)
  , recordJobStatusState :: !(Maybe Text) -- ^ "state" - Current state of the job (e.g., created, completed)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecordJobStatus
instance A.FromJSON RecordJobStatus where
  parseJSON = A.withObject "RecordJobStatus" $ \o ->
    RecordJobStatus
      <$> (o .:? "jobId")
      <*> (o .:? "batchId")
      <*> (o .:? "state")

-- | ToJSON RecordJobStatus
instance A.ToJSON RecordJobStatus where
  toJSON RecordJobStatus {..} =
   _omitNulls
      [ "jobId" .= recordJobStatusJobId
      , "batchId" .= recordJobStatusBatchId
      , "state" .= recordJobStatusState
      ]


-- | Construct a value of type 'RecordJobStatus' (by applying it's required fields, if any)
mkRecordJobStatus
  :: RecordJobStatus
mkRecordJobStatus =
  RecordJobStatus
  { recordJobStatusJobId = Nothing
  , recordJobStatusBatchId = Nothing
  , recordJobStatusState = Nothing
  }

-- ** RecordList
-- | RecordList
-- RecordList
-- 
data RecordList = RecordList
  { recordListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , recordListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , recordListData :: !(Maybe [Record]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecordList
instance A.FromJSON RecordList where
  parseJSON = A.withObject "RecordList" $ \o ->
    RecordList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON RecordList
instance A.ToJSON RecordList where
  toJSON RecordList {..} =
   _omitNulls
      [ "metadata" .= recordListMetadata
      , "pagination" .= recordListPagination
      , "data" .= recordListData
      ]


-- | Construct a value of type 'RecordList' (by applying it's required fields, if any)
mkRecordList
  :: RecordList
mkRecordList =
  RecordList
  { recordListMetadata = Nothing
  , recordListPagination = Nothing
  , recordListData = Nothing
  }

-- ** RecordRevision
-- | RecordRevision
-- RecordRevision
-- 
data RecordRevision = RecordRevision
  { recordRevisionStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , recordRevisionRecordRevisionId :: !(Maybe Int) -- ^ "recordRevisionId" - Unique system identifier for the record revision
  , recordRevisionRecordId :: !(Maybe Int) -- ^ "recordId" - Unique system identifier of the related record
  , recordRevisionRecordOid :: !(Maybe Text) -- ^ "recordOid" - Client-assigned record OID (if any)
  , recordRevisionRecordRevision :: !(Maybe Int) -- ^ "recordRevision" - Revision number of the record (version of the record status)
  , recordRevisionDataRevision :: !(Maybe Int) -- ^ "dataRevision" - Revision number of the data within the record
  , recordRevisionRecordStatus :: !(Maybe Text) -- ^ "recordStatus" - Status of the record at this revision (user-defined status label)
  , recordRevisionSubjectId :: !(Maybe Int) -- ^ "subjectId" - Mednet subject ID related to the record
  , recordRevisionSubjectOid :: !(Maybe Text) -- ^ "subjectOid" - Client-assigned subject OID related to the record
  , recordRevisionSubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Subject display ID related to the record
  , recordRevisionSiteId :: !(Maybe Int) -- ^ "siteId" - Site ID related to the record
  , recordRevisionFormKey :: !(Maybe Text) -- ^ "formKey" - Form key of the form that the record belongs to
  , recordRevisionIntervalId :: !(Maybe Int) -- ^ "intervalId" - Interval ID (visit definition) related to the record
  , recordRevisionRole :: !(Maybe Text) -- ^ "role" - Role name of the user who saved the record revision
  , recordRevisionUser :: !(Maybe Text) -- ^ "user" - Username of the user who saved the record revision
  , recordRevisionReasonForChange :: !(Maybe Text) -- ^ "reasonForChange" - Reason for change, if provided (for audit trail)
  , recordRevisionDeleted :: !(Maybe Bool) -- ^ "deleted" - Whether the record was deleted in this revision
  , recordRevisionDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this record revision was created
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecordRevision
instance A.FromJSON RecordRevision where
  parseJSON = A.withObject "RecordRevision" $ \o ->
    RecordRevision
      <$> (o .:? "studyKey")
      <*> (o .:? "recordRevisionId")
      <*> (o .:? "recordId")
      <*> (o .:? "recordOid")
      <*> (o .:? "recordRevision")
      <*> (o .:? "dataRevision")
      <*> (o .:? "recordStatus")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectOid")
      <*> (o .:? "subjectKey")
      <*> (o .:? "siteId")
      <*> (o .:? "formKey")
      <*> (o .:? "intervalId")
      <*> (o .:? "role")
      <*> (o .:? "user")
      <*> (o .:? "reasonForChange")
      <*> (o .:? "deleted")
      <*> (o .:? "dateCreated")

-- | ToJSON RecordRevision
instance A.ToJSON RecordRevision where
  toJSON RecordRevision {..} =
   _omitNulls
      [ "studyKey" .= recordRevisionStudyKey
      , "recordRevisionId" .= recordRevisionRecordRevisionId
      , "recordId" .= recordRevisionRecordId
      , "recordOid" .= recordRevisionRecordOid
      , "recordRevision" .= recordRevisionRecordRevision
      , "dataRevision" .= recordRevisionDataRevision
      , "recordStatus" .= recordRevisionRecordStatus
      , "subjectId" .= recordRevisionSubjectId
      , "subjectOid" .= recordRevisionSubjectOid
      , "subjectKey" .= recordRevisionSubjectKey
      , "siteId" .= recordRevisionSiteId
      , "formKey" .= recordRevisionFormKey
      , "intervalId" .= recordRevisionIntervalId
      , "role" .= recordRevisionRole
      , "user" .= recordRevisionUser
      , "reasonForChange" .= recordRevisionReasonForChange
      , "deleted" .= recordRevisionDeleted
      , "dateCreated" .= recordRevisionDateCreated
      ]


-- | Construct a value of type 'RecordRevision' (by applying it's required fields, if any)
mkRecordRevision
  :: RecordRevision
mkRecordRevision =
  RecordRevision
  { recordRevisionStudyKey = Nothing
  , recordRevisionRecordRevisionId = Nothing
  , recordRevisionRecordId = Nothing
  , recordRevisionRecordOid = Nothing
  , recordRevisionRecordRevision = Nothing
  , recordRevisionDataRevision = Nothing
  , recordRevisionRecordStatus = Nothing
  , recordRevisionSubjectId = Nothing
  , recordRevisionSubjectOid = Nothing
  , recordRevisionSubjectKey = Nothing
  , recordRevisionSiteId = Nothing
  , recordRevisionFormKey = Nothing
  , recordRevisionIntervalId = Nothing
  , recordRevisionRole = Nothing
  , recordRevisionUser = Nothing
  , recordRevisionReasonForChange = Nothing
  , recordRevisionDeleted = Nothing
  , recordRevisionDateCreated = Nothing
  }

-- ** RecordRevisionList
-- | RecordRevisionList
-- RecordRevisionList
-- 
data RecordRevisionList = RecordRevisionList
  { recordRevisionListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , recordRevisionListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , recordRevisionListData :: !(Maybe [RecordRevision]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecordRevisionList
instance A.FromJSON RecordRevisionList where
  parseJSON = A.withObject "RecordRevisionList" $ \o ->
    RecordRevisionList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON RecordRevisionList
instance A.ToJSON RecordRevisionList where
  toJSON RecordRevisionList {..} =
   _omitNulls
      [ "metadata" .= recordRevisionListMetadata
      , "pagination" .= recordRevisionListPagination
      , "data" .= recordRevisionListData
      ]


-- | Construct a value of type 'RecordRevisionList' (by applying it's required fields, if any)
mkRecordRevisionList
  :: RecordRevisionList
mkRecordRevisionList =
  RecordRevisionList
  { recordRevisionListMetadata = Nothing
  , recordRevisionListPagination = Nothing
  , recordRevisionListData = Nothing
  }

-- ** Role
-- | Role
-- Role
-- 
data Role = Role
  { roleDateCreated :: !(Maybe [Int]) -- ^ "dateCreated" - Timestamp when the role assignment was created (as [year, month, day, hour, minute, second, nanosecond])
  , roleDateModified :: !(Maybe [Int]) -- ^ "dateModified" - Timestamp when the role assignment was last modified
  , roleRoleId :: !(Maybe Text) -- ^ "roleId" - Unique role ID (UUID)
  , roleCommunityId :: !(Maybe Int) -- ^ "communityId" - Community ID or level associated with the role
  , roleName :: !(Maybe Text) -- ^ "name" - Name of the role
  , roleDescription :: !(Maybe Text) -- ^ "description" - Description of the role
  , roleLevel :: !(Maybe Int) -- ^ "level" - Role level or hierarchy
  , roleType :: !(Maybe Text) -- ^ "type" - Role type/category
  , roleInactive :: !(Maybe Bool) -- ^ "inactive" - Whether the role is inactive
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Role
instance A.FromJSON Role where
  parseJSON = A.withObject "Role" $ \o ->
    Role
      <$> (o .:? "dateCreated")
      <*> (o .:? "dateModified")
      <*> (o .:? "roleId")
      <*> (o .:? "communityId")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "level")
      <*> (o .:? "type")
      <*> (o .:? "inactive")

-- | ToJSON Role
instance A.ToJSON Role where
  toJSON Role {..} =
   _omitNulls
      [ "dateCreated" .= roleDateCreated
      , "dateModified" .= roleDateModified
      , "roleId" .= roleRoleId
      , "communityId" .= roleCommunityId
      , "name" .= roleName
      , "description" .= roleDescription
      , "level" .= roleLevel
      , "type" .= roleType
      , "inactive" .= roleInactive
      ]


-- | Construct a value of type 'Role' (by applying it's required fields, if any)
mkRole
  :: Role
mkRole =
  Role
  { roleDateCreated = Nothing
  , roleDateModified = Nothing
  , roleRoleId = Nothing
  , roleCommunityId = Nothing
  , roleName = Nothing
  , roleDescription = Nothing
  , roleLevel = Nothing
  , roleType = Nothing
  , roleInactive = Nothing
  }

-- ** Site
-- | Site
-- Site
-- 
data Site = Site
  { siteStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , siteSiteId :: !(Maybe Int) -- ^ "siteId" - Unique site ID
  , siteSiteName :: !(Maybe Text) -- ^ "siteName" - Name of the site
  , siteSiteEnrollmentStatus :: !(Maybe Text) -- ^ "siteEnrollmentStatus" - Enrollment status of the site
  , siteDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this site was created
  , siteDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this site was last modified
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Site
instance A.FromJSON Site where
  parseJSON = A.withObject "Site" $ \o ->
    Site
      <$> (o .:? "studyKey")
      <*> (o .:? "siteId")
      <*> (o .:? "siteName")
      <*> (o .:? "siteEnrollmentStatus")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")

-- | ToJSON Site
instance A.ToJSON Site where
  toJSON Site {..} =
   _omitNulls
      [ "studyKey" .= siteStudyKey
      , "siteId" .= siteSiteId
      , "siteName" .= siteSiteName
      , "siteEnrollmentStatus" .= siteSiteEnrollmentStatus
      , "dateCreated" .= siteDateCreated
      , "dateModified" .= siteDateModified
      ]


-- | Construct a value of type 'Site' (by applying it's required fields, if any)
mkSite
  :: Site
mkSite =
  Site
  { siteStudyKey = Nothing
  , siteSiteId = Nothing
  , siteSiteName = Nothing
  , siteSiteEnrollmentStatus = Nothing
  , siteDateCreated = Nothing
  , siteDateModified = Nothing
  }

-- ** SiteList
-- | SiteList
-- SiteList
-- 
data SiteList = SiteList
  { siteListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , siteListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , siteListData :: !(Maybe [Site]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SiteList
instance A.FromJSON SiteList where
  parseJSON = A.withObject "SiteList" $ \o ->
    SiteList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON SiteList
instance A.ToJSON SiteList where
  toJSON SiteList {..} =
   _omitNulls
      [ "metadata" .= siteListMetadata
      , "pagination" .= siteListPagination
      , "data" .= siteListData
      ]


-- | Construct a value of type 'SiteList' (by applying it's required fields, if any)
mkSiteList
  :: SiteList
mkSiteList =
  SiteList
  { siteListMetadata = Nothing
  , siteListPagination = Nothing
  , siteListData = Nothing
  }

-- ** Sort
-- | Sort
-- Sort
-- 
data Sort = Sort
  { sortProperty :: !(Maybe Text) -- ^ "property" - Name of the property by which the result is sorted
  , sortDirection :: !(Maybe E'Direction) -- ^ "direction" - Sort direction (ASC or DESC)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Sort
instance A.FromJSON Sort where
  parseJSON = A.withObject "Sort" $ \o ->
    Sort
      <$> (o .:? "property")
      <*> (o .:? "direction")

-- | ToJSON Sort
instance A.ToJSON Sort where
  toJSON Sort {..} =
   _omitNulls
      [ "property" .= sortProperty
      , "direction" .= sortDirection
      ]


-- | Construct a value of type 'Sort' (by applying it's required fields, if any)
mkSort
  :: Sort
mkSort =
  Sort
  { sortProperty = Nothing
  , sortDirection = Nothing
  }

-- ** Study
-- | Study
-- Study
-- 
data Study = Study
  { studySponsorKey :: !(Maybe Text) -- ^ "sponsorKey" - Sponsor key that this study belongs to
  , studyStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , studyStudyId :: !(Maybe Int) -- ^ "studyId" - Mednet study ID (internal numeric identifier)
  , studyStudyName :: !(Maybe Text) -- ^ "studyName" - Name of the study
  , studyStudyDescription :: !(Maybe Text) -- ^ "studyDescription" - Description of the study
  , studyStudyType :: !(Maybe Text) -- ^ "studyType" - Type of study (e.g., STUDY)
  , studyDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when the study record was created
  , studyDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when the study record was last modified
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Study
instance A.FromJSON Study where
  parseJSON = A.withObject "Study" $ \o ->
    Study
      <$> (o .:? "sponsorKey")
      <*> (o .:? "studyKey")
      <*> (o .:? "studyId")
      <*> (o .:? "studyName")
      <*> (o .:? "studyDescription")
      <*> (o .:? "studyType")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")

-- | ToJSON Study
instance A.ToJSON Study where
  toJSON Study {..} =
   _omitNulls
      [ "sponsorKey" .= studySponsorKey
      , "studyKey" .= studyStudyKey
      , "studyId" .= studyStudyId
      , "studyName" .= studyStudyName
      , "studyDescription" .= studyStudyDescription
      , "studyType" .= studyStudyType
      , "dateCreated" .= studyDateCreated
      , "dateModified" .= studyDateModified
      ]


-- | Construct a value of type 'Study' (by applying it's required fields, if any)
mkStudy
  :: Study
mkStudy =
  Study
  { studySponsorKey = Nothing
  , studyStudyKey = Nothing
  , studyStudyId = Nothing
  , studyStudyName = Nothing
  , studyStudyDescription = Nothing
  , studyStudyType = Nothing
  , studyDateCreated = Nothing
  , studyDateModified = Nothing
  }

-- ** StudyList
-- | StudyList
-- StudyList
-- 
data StudyList = StudyList
  { studyListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , studyListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , studyListData :: !(Maybe [Study]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StudyList
instance A.FromJSON StudyList where
  parseJSON = A.withObject "StudyList" $ \o ->
    StudyList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON StudyList
instance A.ToJSON StudyList where
  toJSON StudyList {..} =
   _omitNulls
      [ "metadata" .= studyListMetadata
      , "pagination" .= studyListPagination
      , "data" .= studyListData
      ]


-- | Construct a value of type 'StudyList' (by applying it's required fields, if any)
mkStudyList
  :: StudyList
mkStudyList =
  StudyList
  { studyListMetadata = Nothing
  , studyListPagination = Nothing
  , studyListData = Nothing
  }

-- ** Subject
-- | Subject
-- Subject
-- 
data Subject = Subject
  { subjectStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , subjectSubjectId :: !(Maybe Int) -- ^ "subjectId" - Mednet subject ID (internal numeric ID)
  , subjectSubjectOid :: !(Maybe Text) -- ^ "subjectOid" - Client-assigned subject object identifier (OID)
  , subjectSubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Protocol-assigned subject identifier (display ID)
  , subjectSubjectStatus :: !(Maybe Text) -- ^ "subjectStatus" - Current status of the subject (e.g., Enrolled)
  , subjectSiteId :: !(Maybe Int) -- ^ "siteId" - Mednet site ID the subject is associated with
  , subjectSiteName :: !(Maybe Text) -- ^ "siteName" - Name of the site the subject is associated with
  , subjectDeleted :: !(Maybe Bool) -- ^ "deleted" - Whether the subject is marked as deleted
  , subjectEnrollmentStartDate :: !(Maybe Text) -- ^ "enrollmentStartDate" - Subjectâ€™s enrollment start date
  , subjectDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this subject record was created
  , subjectDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this subject record was last modified
  , subjectKeywords :: !(Maybe [Keyword]) -- ^ "keywords" - List of keywords associated with the subject
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Subject
instance A.FromJSON Subject where
  parseJSON = A.withObject "Subject" $ \o ->
    Subject
      <$> (o .:? "studyKey")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectOid")
      <*> (o .:? "subjectKey")
      <*> (o .:? "subjectStatus")
      <*> (o .:? "siteId")
      <*> (o .:? "siteName")
      <*> (o .:? "deleted")
      <*> (o .:? "enrollmentStartDate")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")
      <*> (o .:? "keywords")

-- | ToJSON Subject
instance A.ToJSON Subject where
  toJSON Subject {..} =
   _omitNulls
      [ "studyKey" .= subjectStudyKey
      , "subjectId" .= subjectSubjectId
      , "subjectOid" .= subjectSubjectOid
      , "subjectKey" .= subjectSubjectKey
      , "subjectStatus" .= subjectSubjectStatus
      , "siteId" .= subjectSiteId
      , "siteName" .= subjectSiteName
      , "deleted" .= subjectDeleted
      , "enrollmentStartDate" .= subjectEnrollmentStartDate
      , "dateCreated" .= subjectDateCreated
      , "dateModified" .= subjectDateModified
      , "keywords" .= subjectKeywords
      ]


-- | Construct a value of type 'Subject' (by applying it's required fields, if any)
mkSubject
  :: Subject
mkSubject =
  Subject
  { subjectStudyKey = Nothing
  , subjectSubjectId = Nothing
  , subjectSubjectOid = Nothing
  , subjectSubjectKey = Nothing
  , subjectSubjectStatus = Nothing
  , subjectSiteId = Nothing
  , subjectSiteName = Nothing
  , subjectDeleted = Nothing
  , subjectEnrollmentStartDate = Nothing
  , subjectDateCreated = Nothing
  , subjectDateModified = Nothing
  , subjectKeywords = Nothing
  }

-- ** SubjectList
-- | SubjectList
-- SubjectList
-- 
data SubjectList = SubjectList
  { subjectListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , subjectListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , subjectListData :: !(Maybe [Subject]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubjectList
instance A.FromJSON SubjectList where
  parseJSON = A.withObject "SubjectList" $ \o ->
    SubjectList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON SubjectList
instance A.ToJSON SubjectList where
  toJSON SubjectList {..} =
   _omitNulls
      [ "metadata" .= subjectListMetadata
      , "pagination" .= subjectListPagination
      , "data" .= subjectListData
      ]


-- | Construct a value of type 'SubjectList' (by applying it's required fields, if any)
mkSubjectList
  :: SubjectList
mkSubjectList =
  SubjectList
  { subjectListMetadata = Nothing
  , subjectListPagination = Nothing
  , subjectListData = Nothing
  }

-- ** User
-- | User
-- User
-- 
data User = User
  { userUserId :: !(Maybe Text) -- ^ "userId" - Unique user ID (UUID)
  , userLogin :: !(Maybe Text) -- ^ "login" - User login name
  , userFirstName :: !(Maybe Text) -- ^ "firstName" - User first name
  , userLastName :: !(Maybe Text) -- ^ "lastName" - User last name
  , userEmail :: !(Maybe Text) -- ^ "email" - User email address
  , userUserActiveInStudy :: !(Maybe Bool) -- ^ "userActiveInStudy" - Whether the user is active in the given study
  , userRoles :: !(Maybe [Role]) -- ^ "roles" - Roles that the user has in the study
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "userId")
      <*> (o .:? "login")
      <*> (o .:? "firstName")
      <*> (o .:? "lastName")
      <*> (o .:? "email")
      <*> (o .:? "userActiveInStudy")
      <*> (o .:? "roles")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "userId" .= userUserId
      , "login" .= userLogin
      , "firstName" .= userFirstName
      , "lastName" .= userLastName
      , "email" .= userEmail
      , "userActiveInStudy" .= userUserActiveInStudy
      , "roles" .= userRoles
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userUserId = Nothing
  , userLogin = Nothing
  , userFirstName = Nothing
  , userLastName = Nothing
  , userEmail = Nothing
  , userUserActiveInStudy = Nothing
  , userRoles = Nothing
  }

-- ** UserList
-- | UserList
-- UserList
-- 
data UserList = UserList
  { userListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , userListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , userListData :: !(Maybe [User]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserList
instance A.FromJSON UserList where
  parseJSON = A.withObject "UserList" $ \o ->
    UserList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON UserList
instance A.ToJSON UserList where
  toJSON UserList {..} =
   _omitNulls
      [ "metadata" .= userListMetadata
      , "pagination" .= userListPagination
      , "data" .= userListData
      ]


-- | Construct a value of type 'UserList' (by applying it's required fields, if any)
mkUserList
  :: UserList
mkUserList =
  UserList
  { userListMetadata = Nothing
  , userListPagination = Nothing
  , userListData = Nothing
  }

-- ** Variable
-- | Variable
-- Variable
-- 
data Variable = Variable
  { variableStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , variableVariableId :: !(Maybe Int) -- ^ "variableId" - Mednet variable ID
  , variableVariableType :: !(Maybe E'VariableType) -- ^ "variableType" - Type of the variable (field type), e.g., RADIO, TEXT, etc.
  , variableVariableName :: !(Maybe Text) -- ^ "variableName" - Name of the variable (question text or label)
  , variableSequence :: !(Maybe Int) -- ^ "sequence" - Sequence of the variable on the form
  , variableRevision :: !(Maybe Int) -- ^ "revision" - Number of modifications of the variable (via form metadata revisions)
  , variableDisabled :: !(Maybe Bool) -- ^ "disabled" - Whether the variable is marked as disabled (deleted)
  , variableDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this variable was created
  , variableDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this variable was last modified
  , variableFormId :: !(Maybe Int) -- ^ "formId" - ID of the form that this variable belongs to
  , variableVariableOid :: !(Maybe Text) -- ^ "variableOid" - Client-assigned variable OID
  , variableDeleted :: !(Maybe Bool) -- ^ "deleted" - Whether the variable is marked as deleted
  , variableFormKey :: !(Maybe Text) -- ^ "formKey" - Form key of the form that this variable belongs to
  , variableFormName :: !(Maybe Text) -- ^ "formName" - Name of the form that this variable belongs to
  , variableLabel :: !(Maybe Text) -- ^ "label" - User-defined identifier (field name) for the variable
  , variableBlinded :: !(Maybe Bool) -- ^ "blinded" - Whether the variable is flagged as blinded (hidden in certain contexts)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Variable
instance A.FromJSON Variable where
  parseJSON = A.withObject "Variable" $ \o ->
    Variable
      <$> (o .:? "studyKey")
      <*> (o .:? "variableId")
      <*> (o .:? "variableType")
      <*> (o .:? "variableName")
      <*> (o .:? "sequence")
      <*> (o .:? "revision")
      <*> (o .:? "disabled")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")
      <*> (o .:? "formId")
      <*> (o .:? "variableOid")
      <*> (o .:? "deleted")
      <*> (o .:? "formKey")
      <*> (o .:? "formName")
      <*> (o .:? "label")
      <*> (o .:? "blinded")

-- | ToJSON Variable
instance A.ToJSON Variable where
  toJSON Variable {..} =
   _omitNulls
      [ "studyKey" .= variableStudyKey
      , "variableId" .= variableVariableId
      , "variableType" .= variableVariableType
      , "variableName" .= variableVariableName
      , "sequence" .= variableSequence
      , "revision" .= variableRevision
      , "disabled" .= variableDisabled
      , "dateCreated" .= variableDateCreated
      , "dateModified" .= variableDateModified
      , "formId" .= variableFormId
      , "variableOid" .= variableVariableOid
      , "deleted" .= variableDeleted
      , "formKey" .= variableFormKey
      , "formName" .= variableFormName
      , "label" .= variableLabel
      , "blinded" .= variableBlinded
      ]


-- | Construct a value of type 'Variable' (by applying it's required fields, if any)
mkVariable
  :: Variable
mkVariable =
  Variable
  { variableStudyKey = Nothing
  , variableVariableId = Nothing
  , variableVariableType = Nothing
  , variableVariableName = Nothing
  , variableSequence = Nothing
  , variableRevision = Nothing
  , variableDisabled = Nothing
  , variableDateCreated = Nothing
  , variableDateModified = Nothing
  , variableFormId = Nothing
  , variableVariableOid = Nothing
  , variableDeleted = Nothing
  , variableFormKey = Nothing
  , variableFormName = Nothing
  , variableLabel = Nothing
  , variableBlinded = Nothing
  }

-- ** VariableList
-- | VariableList
-- VariableList
-- 
data VariableList = VariableList
  { variableListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , variableListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , variableListData :: !(Maybe [Variable]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VariableList
instance A.FromJSON VariableList where
  parseJSON = A.withObject "VariableList" $ \o ->
    VariableList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON VariableList
instance A.ToJSON VariableList where
  toJSON VariableList {..} =
   _omitNulls
      [ "metadata" .= variableListMetadata
      , "pagination" .= variableListPagination
      , "data" .= variableListData
      ]


-- | Construct a value of type 'VariableList' (by applying it's required fields, if any)
mkVariableList
  :: VariableList
mkVariableList =
  VariableList
  { variableListMetadata = Nothing
  , variableListPagination = Nothing
  , variableListData = Nothing
  }

-- ** Visit
-- | Visit
-- Visit
-- 
data Visit = Visit
  { visitStudyKey :: !(Maybe Text) -- ^ "studyKey" - Unique study key
  , visitVisitId :: !(Maybe Int) -- ^ "visitId" - Unique system identifier for the subject visit instance
  , visitIntervalId :: !(Maybe Int) -- ^ "intervalId" - Unique system identifier of the interval definition for this visit
  , visitIntervalName :: !(Maybe Text) -- ^ "intervalName" - Name of the interval (visit) for this visit instance
  , visitSubjectId :: !(Maybe Int) -- ^ "subjectId" - Mednet subject ID of the subject
  , visitSubjectKey :: !(Maybe Text) -- ^ "subjectKey" - Protocol-assigned subject identifier
  , visitStartDate :: !(Maybe Text) -- ^ "startDate" - Start date of the visit window (in YYYY-MM-DD format)
  , visitEndDate :: !(Maybe Text) -- ^ "endDate" - End date of the visit window (in YYYY-MM-DD format)
  , visitDueDate :: !(Maybe Text) -- ^ "dueDate" - Due date of the visit (in YYYY-MM-DD format), if applicable
  , visitVisitDate :: !(Maybe Text) -- ^ "visitDate" - Actual date the visit took place (in YYYY-MM-DD format)
  , visitVisitDateForm :: !(Maybe Text) -- ^ "visitDateForm" - Name of the form used to capture the actual visit date
  , visitVisitDateQuestion :: !(Maybe Text) -- ^ "visitDateQuestion" - Variable name of the field capturing the actual visit date
  , visitDeleted :: !(Maybe Bool) -- ^ "deleted" - Whether the visit instance is marked as deleted
  , visitDateCreated :: !(Maybe Text) -- ^ "dateCreated" - Date when this visit record was created
  , visitDateModified :: !(Maybe Text) -- ^ "dateModified" - Date when this visit record was last modified
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Visit
instance A.FromJSON Visit where
  parseJSON = A.withObject "Visit" $ \o ->
    Visit
      <$> (o .:? "studyKey")
      <*> (o .:? "visitId")
      <*> (o .:? "intervalId")
      <*> (o .:? "intervalName")
      <*> (o .:? "subjectId")
      <*> (o .:? "subjectKey")
      <*> (o .:? "startDate")
      <*> (o .:? "endDate")
      <*> (o .:? "dueDate")
      <*> (o .:? "visitDate")
      <*> (o .:? "visitDateForm")
      <*> (o .:? "visitDateQuestion")
      <*> (o .:? "deleted")
      <*> (o .:? "dateCreated")
      <*> (o .:? "dateModified")

-- | ToJSON Visit
instance A.ToJSON Visit where
  toJSON Visit {..} =
   _omitNulls
      [ "studyKey" .= visitStudyKey
      , "visitId" .= visitVisitId
      , "intervalId" .= visitIntervalId
      , "intervalName" .= visitIntervalName
      , "subjectId" .= visitSubjectId
      , "subjectKey" .= visitSubjectKey
      , "startDate" .= visitStartDate
      , "endDate" .= visitEndDate
      , "dueDate" .= visitDueDate
      , "visitDate" .= visitVisitDate
      , "visitDateForm" .= visitVisitDateForm
      , "visitDateQuestion" .= visitVisitDateQuestion
      , "deleted" .= visitDeleted
      , "dateCreated" .= visitDateCreated
      , "dateModified" .= visitDateModified
      ]


-- | Construct a value of type 'Visit' (by applying it's required fields, if any)
mkVisit
  :: Visit
mkVisit =
  Visit
  { visitStudyKey = Nothing
  , visitVisitId = Nothing
  , visitIntervalId = Nothing
  , visitIntervalName = Nothing
  , visitSubjectId = Nothing
  , visitSubjectKey = Nothing
  , visitStartDate = Nothing
  , visitEndDate = Nothing
  , visitDueDate = Nothing
  , visitVisitDate = Nothing
  , visitVisitDateForm = Nothing
  , visitVisitDateQuestion = Nothing
  , visitDeleted = Nothing
  , visitDateCreated = Nothing
  , visitDateModified = Nothing
  }

-- ** VisitList
-- | VisitList
-- VisitList
-- 
data VisitList = VisitList
  { visitListMetadata :: !(Maybe Metadata) -- ^ "metadata"
  , visitListPagination :: !(Maybe Pagination) -- ^ "pagination"
  , visitListData :: !(Maybe [Visit]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VisitList
instance A.FromJSON VisitList where
  parseJSON = A.withObject "VisitList" $ \o ->
    VisitList
      <$> (o .:? "metadata")
      <*> (o .:? "pagination")
      <*> (o .:? "data")

-- | ToJSON VisitList
instance A.ToJSON VisitList where
  toJSON VisitList {..} =
   _omitNulls
      [ "metadata" .= visitListMetadata
      , "pagination" .= visitListPagination
      , "data" .= visitListData
      ]


-- | Construct a value of type 'VisitList' (by applying it's required fields, if any)
mkVisitList
  :: VisitList
mkVisitList =
  VisitList
  { visitListMetadata = Nothing
  , visitListPagination = Nothing
  , visitListData = Nothing
  }


-- * Enums


-- ** E'Direction

-- | Enum of 'Text' .
-- Sort direction (ASC or DESC)
data E'Direction
  = E'Direction'ASC -- ^ @"ASC"@
  | E'Direction'DESC -- ^ @"DESC"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Direction where toJSON = A.toJSON . fromE'Direction
instance A.FromJSON E'Direction where parseJSON o = P.either P.fail (pure . P.id) . toE'Direction =<< A.parseJSON o
instance WH.ToHttpApiData E'Direction where toQueryParam = WH.toQueryParam . fromE'Direction
instance WH.FromHttpApiData E'Direction where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Direction
instance MimeRender MimeMultipartFormData E'Direction where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Direction' enum
fromE'Direction :: E'Direction -> Text
fromE'Direction = \case
  E'Direction'ASC -> "ASC"
  E'Direction'DESC -> "DESC"

-- | parse 'E'Direction' enum
toE'Direction :: Text -> P.Either String E'Direction
toE'Direction = \case
  "ASC" -> P.Right E'Direction'ASC
  "DESC" -> P.Right E'Direction'DESC
  s -> P.Left $ "toE'Direction: enum parse failure: " P.++ P.show s


-- ** E'VariableType

-- | Enum of 'Text' .
-- Type of the variable (field type), e.g., RADIO, TEXT, etc.
data E'VariableType
  = E'VariableType'TEXT -- ^ @"TEXT"@
  | E'VariableType'TEXTAREA -- ^ @"TEXTAREA"@
  | E'VariableType'RADIO -- ^ @"RADIO"@
  | E'VariableType'CHECKBOX -- ^ @"CHECKBOX"@
  | E'VariableType'DROPDOWN -- ^ @"DROPDOWN"@
  | E'VariableType'DATE -- ^ @"DATE"@
  | E'VariableType'NUMBER -- ^ @"NUMBER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'VariableType where toJSON = A.toJSON . fromE'VariableType
instance A.FromJSON E'VariableType where parseJSON o = P.either P.fail (pure . P.id) . toE'VariableType =<< A.parseJSON o
instance WH.ToHttpApiData E'VariableType where toQueryParam = WH.toQueryParam . fromE'VariableType
instance WH.FromHttpApiData E'VariableType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'VariableType
instance MimeRender MimeMultipartFormData E'VariableType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'VariableType' enum
fromE'VariableType :: E'VariableType -> Text
fromE'VariableType = \case
  E'VariableType'TEXT -> "TEXT"
  E'VariableType'TEXTAREA -> "TEXTAREA"
  E'VariableType'RADIO -> "RADIO"
  E'VariableType'CHECKBOX -> "CHECKBOX"
  E'VariableType'DROPDOWN -> "DROPDOWN"
  E'VariableType'DATE -> "DATE"
  E'VariableType'NUMBER -> "NUMBER"

-- | parse 'E'VariableType' enum
toE'VariableType :: Text -> P.Either String E'VariableType
toE'VariableType = \case
  "TEXT" -> P.Right E'VariableType'TEXT
  "TEXTAREA" -> P.Right E'VariableType'TEXTAREA
  "RADIO" -> P.Right E'VariableType'RADIO
  "CHECKBOX" -> P.Right E'VariableType'CHECKBOX
  "DROPDOWN" -> P.Right E'VariableType'DROPDOWN
  "DATE" -> P.Right E'VariableType'DATE
  "NUMBER" -> P.Right E'VariableType'NUMBER
  s -> P.Left $ "toE'VariableType: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKeyAuth
data AuthApiKeyApiKeyAuth =
  AuthApiKeyApiKeyAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyAuth where
  applyAuthMethod _ a@(AuthApiKeyApiKeyAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeySecurityKeyAuth
data AuthApiKeySecurityKeyAuth =
  AuthApiKeySecurityKeyAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeySecurityKeyAuth where
  applyAuthMethod _ a@(AuthApiKeySecurityKeyAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-imn-security-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


