/** Mednet EDC API
  * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
  *
  * The version of the OpenAPI document: 1.3.6
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.apis

import cats.effect.Concurrent
import io.circe.Encoder
import org.http4s.Uri
import org.http4s.client.Client as Http4sClient
import org.openapitools.client.models.ComponentsSchemasRecordCreateRequestItem
import org.openapitools.client.models.InlineObject
import org.openapitools.client.models.InlineObject1
import org.openapitools.client.models.InlineObject2
import org.openapitools.client.models.InlineObject3
import org.openapitools.client.models.InlineObject4
import org.openapitools.client.models.InlineObject5
import org.openapitools.client.models.RecordJobStatus
import org.openapitools.client.models.RecordList
import scala.collection.immutable.Seq
import org.openapitools.client.models.*

trait RecordsApiEndpoints[F[*]] {

  def createRecords(studyKey: String, componentsSchemasRecordCreateRequestItem: Seq[ComponentsSchemasRecordCreateRequestItem])(using auth: _Authorization.ApiKey): F[RecordJobStatus]
  def listRecords(studyKey: String, page: Option[Int] = None, size: Option[Int] = None, sort: Option[String] = None, filter: Option[String] = None, recordDataFilter: Option[String] = None)(using auth: _Authorization.ApiKey): F[RecordList]

}

class RecordsApiEndpointsImpl[F[*]: Concurrent](
  override val baseUrl: Uri,
  defaultHeaders: Seq[(String, String)] = Nil,
  httpClient: Http4sClient[F]
) extends BaseClient[F](baseUrl, defaultHeaders, httpClient) with RecordsApiEndpoints[F] {
  
  import JsonSupports.*
  import io.circe.syntax.EncoderOps
  import cats.implicits.toFlatMapOps

  override def createRecords(studyKey: String, componentsSchemasRecordCreateRequestItem: Seq[ComponentsSchemasRecordCreateRequestItem])(using auth: _Authorization.ApiKey): F[RecordJobStatus] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten

    _executeRequest[Seq[ComponentsSchemasRecordCreateRequestItem], RecordJobStatus](
      method = "POST",
      path = s"/studies/${studyKey}/records",
      body = Some(componentsSchemasRecordCreateRequestItem),
      formParameters = None,
      queryParameters = Nil,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 202 => parseJson[F, RecordJobStatus]("RecordJobStatus", r)
        case r if r.status.code == 400 => parseJson[F, InlineObject]("InlineObject", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, InlineObject1]("InlineObject1", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, InlineObject2]("InlineObject2", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, InlineObject3]("InlineObject3", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 429 => parseJson[F, InlineObject4]("InlineObject4", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, InlineObject5]("InlineObject5", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

  override def listRecords(studyKey: String, page: Option[Int] = None, size: Option[Int] = None, sort: Option[String] = None, filter: Option[String] = None, recordDataFilter: Option[String] = None)(using auth: _Authorization.ApiKey): F[RecordList] = {
    val requestHeaders = Seq(
      Some("Content-Type" -> "application/json")
    ).flatten
    val queryParameters = (
      page.map("page" -> _).map(Seq(_)) ++ 
      size.map("size" -> _).map(Seq(_)) ++ 
      sort.map("sort" -> _).map(Seq(_)) ++ 
      filter.map("filter" -> _).map(Seq(_)) ++ 
      recordDataFilter.map("recordDataFilter" -> _).map(Seq(_))
    ).toSeq.flatten

    _executeRequest[Unit, RecordList](
      method = "GET",
      path = s"/studies/${studyKey}/records",
      body = None,
      formParameters = None,
      queryParameters = queryParameters,
      requestHeaders = requestHeaders,
      auth = Some(auth)) {
        
        case r if r.status.code == 200 => parseJson[F, RecordList]("RecordList", r)
        case r if r.status.code == 400 => parseJson[F, InlineObject]("InlineObject", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 401 => parseJson[F, InlineObject1]("InlineObject1", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 403 => parseJson[F, InlineObject2]("InlineObject2", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 404 => parseJson[F, InlineObject3]("InlineObject3", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
        case r if r.status.code == 500 => parseJson[F, InlineObject5]("InlineObject5", r).flatMap(res => Concurrent[F].raiseError(_FailedRequest(r.status.code, r.status.reason, Some(res.asJson))))
    }
  }

}


