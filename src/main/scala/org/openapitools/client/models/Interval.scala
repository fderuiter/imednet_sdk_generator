/** Mednet EDC API
  * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
  *
  * The version of the OpenAPI document: 1.3.6
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}

import scala.collection.immutable.Seq

/** 
  * @param studyKey Unique study key
  * @param intervalId Unique system identifier for the interval (visit definition)
  * @param intervalName Name of the interval (visit) as defined in the study
  * @param intervalDescription Description of the interval (visit)
  * @param intervalSequence Sequence number of the interval in the schedule
  * @param intervalGroupId Identifier for the interval group (if intervals are grouped)
  * @param intervalGroupName Name of the interval group
  * @param timeline Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)
  * @param definedUsingInterval Baseline interval used for calculating this intervalâ€™s dates
  * @param windowCalculationForm Baseline form (name) from which the calculation date is taken
  * @param windowCalculationDate Baseline field (variable name) from which the calculation date is taken
  * @param actualDateForm Form used to capture the actual date for this interval
  * @param actualDate Field (variable name) used to capture the actual date for this interval
  * @param dueDateWillBeIn Number of days from the calculation date when the interval is due
  * @param negativeSlack Number of days before the due date that are allowed (negative window)
  * @param positiveSlack Number of days after the due date that are allowed (positive window)
  * @param eproGracePeriod Number of days of grace period for ePRO completion after due date
  * @param forms List of forms that are scheduled in this interval
  * @param disabled Whether the interval is soft-deleted (disabled)
  * @param dateCreated Date when this interval was created
  * @param dateModified Date when this interval was last modified
  */
case class Interval(
    studyKey: Option[String] = None,
    intervalId: Option[Int] = None,
    intervalName: Option[String] = None,
    intervalDescription: Option[String] = None,
    intervalSequence: Option[Int] = None,
    intervalGroupId: Option[Int] = None,
    intervalGroupName: Option[String] = None,
    timeline: Option[String] = None,
    definedUsingInterval: Option[String] = None,
    windowCalculationForm: Option[String] = None,
    windowCalculationDate: Option[String] = None,
    actualDateForm: Option[String] = None,
    actualDate: Option[String] = None,
    dueDateWillBeIn: Option[Int] = None,
    negativeSlack: Option[Int] = None,
    positiveSlack: Option[Int] = None,
    eproGracePeriod: Option[Int] = None,
    forms: Option[Seq[ComponentsSchemasIntervalFormsItem]] = None,
    disabled: Option[Boolean] = None,
    dateCreated: Option[String] = None,
    dateModified: Option[String] = None
)
  
object Interval {
  given encoderInterval: Encoder[Interval] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        t.studyKey.map(v => "studyKey" -> v.asJson),
        t.intervalId.map(v => "intervalId" -> v.asJson),
        t.intervalName.map(v => "intervalName" -> v.asJson),
        t.intervalDescription.map(v => "intervalDescription" -> v.asJson),
        t.intervalSequence.map(v => "intervalSequence" -> v.asJson),
        t.intervalGroupId.map(v => "intervalGroupId" -> v.asJson),
        t.intervalGroupName.map(v => "intervalGroupName" -> v.asJson),
        t.timeline.map(v => "timeline" -> v.asJson),
        t.definedUsingInterval.map(v => "definedUsingInterval" -> v.asJson),
        t.windowCalculationForm.map(v => "windowCalculationForm" -> v.asJson),
        t.windowCalculationDate.map(v => "windowCalculationDate" -> v.asJson),
        t.actualDateForm.map(v => "actualDateForm" -> v.asJson),
        t.actualDate.map(v => "actualDate" -> v.asJson),
        t.dueDateWillBeIn.map(v => "dueDateWillBeIn" -> v.asJson),
        t.negativeSlack.map(v => "negativeSlack" -> v.asJson),
        t.positiveSlack.map(v => "positiveSlack" -> v.asJson),
        t.eproGracePeriod.map(v => "eproGracePeriod" -> v.asJson),
        t.forms.map(v => "forms" -> v.asJson),
        t.disabled.map(v => "disabled" -> v.asJson),
        t.dateCreated.map(v => "dateCreated" -> v.asJson),
        t.dateModified.map(v => "dateModified" -> v.asJson)
      ).flatten
    }
  }
  given decoderInterval: Decoder[Interval] = Decoder.instance { c =>
    for {
      studyKey <- c.downField("studyKey").as[Option[String]]
      intervalId <- c.downField("intervalId").as[Option[Int]]
      intervalName <- c.downField("intervalName").as[Option[String]]
      intervalDescription <- c.downField("intervalDescription").as[Option[String]]
      intervalSequence <- c.downField("intervalSequence").as[Option[Int]]
      intervalGroupId <- c.downField("intervalGroupId").as[Option[Int]]
      intervalGroupName <- c.downField("intervalGroupName").as[Option[String]]
      timeline <- c.downField("timeline").as[Option[String]]
      definedUsingInterval <- c.downField("definedUsingInterval").as[Option[String]]
      windowCalculationForm <- c.downField("windowCalculationForm").as[Option[String]]
      windowCalculationDate <- c.downField("windowCalculationDate").as[Option[String]]
      actualDateForm <- c.downField("actualDateForm").as[Option[String]]
      actualDate <- c.downField("actualDate").as[Option[String]]
      dueDateWillBeIn <- c.downField("dueDateWillBeIn").as[Option[Int]]
      negativeSlack <- c.downField("negativeSlack").as[Option[Int]]
      positiveSlack <- c.downField("positiveSlack").as[Option[Int]]
      eproGracePeriod <- c.downField("eproGracePeriod").as[Option[Int]]
      forms <- c.downField("forms").as[Option[Seq[ComponentsSchemasIntervalFormsItem]]]
      disabled <- c.downField("disabled").as[Option[Boolean]]
      dateCreated <- c.downField("dateCreated").as[Option[String]]
      dateModified <- c.downField("dateModified").as[Option[String]]
    } yield Interval(
      studyKey = studyKey,
      intervalId = intervalId,
      intervalName = intervalName,
      intervalDescription = intervalDescription,
      intervalSequence = intervalSequence,
      intervalGroupId = intervalGroupId,
      intervalGroupName = intervalGroupName,
      timeline = timeline,
      definedUsingInterval = definedUsingInterval,
      windowCalculationForm = windowCalculationForm,
      windowCalculationDate = windowCalculationDate,
      actualDateForm = actualDateForm,
      actualDate = actualDate,
      dueDateWillBeIn = dueDateWillBeIn,
      negativeSlack = negativeSlack,
      positiveSlack = positiveSlack,
      eproGracePeriod = eproGracePeriod,
      forms = forms,
      disabled = disabled,
      dateCreated = dateCreated,
      dateModified = dateModified
    )
  }
}

