<?php
/**
 * Interval
 *
 * PHP version 8.1
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Mednet EDC API
 *
 * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API.
 *
 * The version of the OpenAPI document: 1.3.6
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use ArrayAccess;
use JsonSerializable;
use InvalidArgumentException;
use ReturnTypeWillChange;
use OpenAPI\Client\ObjectSerializer;

/**
 * Interval Class Doc Comment
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements ArrayAccess<string, mixed>
 */
class Interval implements ModelInterface, ArrayAccess, JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static string $openAPIModelName = 'Interval';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array<string, string>
      */
    protected static array $openAPITypes = [
        'study_key' => 'string',
        'interval_id' => 'int',
        'interval_name' => 'string',
        'interval_description' => 'string',
        'interval_sequence' => 'int',
        'interval_group_id' => 'int',
        'interval_group_name' => 'string',
        'timeline' => 'string',
        'defined_using_interval' => 'string',
        'window_calculation_form' => 'string',
        'window_calculation_date' => 'string',
        'actual_date_form' => 'string',
        'actual_date' => 'string',
        'due_date_will_be_in' => 'int',
        'negative_slack' => 'int',
        'positive_slack' => 'int',
        'epro_grace_period' => 'int',
        'forms' => '\OpenAPI\Client\Model\ComponentsSchemasIntervalFormsItem[]',
        'disabled' => 'bool',
        'date_created' => 'string',
        'date_modified' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array<string, string|null>
      */
    protected static array $openAPIFormats = [
        'study_key' => null,
        'interval_id' => null,
        'interval_name' => null,
        'interval_description' => null,
        'interval_sequence' => null,
        'interval_group_id' => null,
        'interval_group_name' => null,
        'timeline' => null,
        'defined_using_interval' => null,
        'window_calculation_form' => null,
        'window_calculation_date' => null,
        'actual_date_form' => null,
        'actual_date' => null,
        'due_date_will_be_in' => null,
        'negative_slack' => null,
        'positive_slack' => null,
        'epro_grace_period' => null,
        'forms' => null,
        'disabled' => null,
        'date_created' => null,
        'date_modified' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var array<string, bool>
      */
    protected static array $openAPINullables = [
        'study_key' => false,
        'interval_id' => false,
        'interval_name' => false,
        'interval_description' => false,
        'interval_sequence' => false,
        'interval_group_id' => false,
        'interval_group_name' => false,
        'timeline' => false,
        'defined_using_interval' => false,
        'window_calculation_form' => false,
        'window_calculation_date' => false,
        'actual_date_form' => false,
        'actual_date' => false,
        'due_date_will_be_in' => false,
        'negative_slack' => false,
        'positive_slack' => false,
        'epro_grace_period' => false,
        'forms' => false,
        'disabled' => false,
        'date_created' => false,
        'date_modified' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var array<string, bool>
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPITypes(): array
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPIFormats(): array
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array<string, bool>
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return array<string, bool>
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param array<string, bool> $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var array<string, string>
     */
    protected static array $attributeMap = [
        'study_key' => 'studyKey',
        'interval_id' => 'intervalId',
        'interval_name' => 'intervalName',
        'interval_description' => 'intervalDescription',
        'interval_sequence' => 'intervalSequence',
        'interval_group_id' => 'intervalGroupId',
        'interval_group_name' => 'intervalGroupName',
        'timeline' => 'timeline',
        'defined_using_interval' => 'definedUsingInterval',
        'window_calculation_form' => 'windowCalculationForm',
        'window_calculation_date' => 'windowCalculationDate',
        'actual_date_form' => 'actualDateForm',
        'actual_date' => 'actualDate',
        'due_date_will_be_in' => 'dueDateWillBeIn',
        'negative_slack' => 'negativeSlack',
        'positive_slack' => 'positiveSlack',
        'epro_grace_period' => 'eproGracePeriod',
        'forms' => 'forms',
        'disabled' => 'disabled',
        'date_created' => 'dateCreated',
        'date_modified' => 'dateModified'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var array<string, string>
     */
    protected static array $setters = [
        'study_key' => 'setStudyKey',
        'interval_id' => 'setIntervalId',
        'interval_name' => 'setIntervalName',
        'interval_description' => 'setIntervalDescription',
        'interval_sequence' => 'setIntervalSequence',
        'interval_group_id' => 'setIntervalGroupId',
        'interval_group_name' => 'setIntervalGroupName',
        'timeline' => 'setTimeline',
        'defined_using_interval' => 'setDefinedUsingInterval',
        'window_calculation_form' => 'setWindowCalculationForm',
        'window_calculation_date' => 'setWindowCalculationDate',
        'actual_date_form' => 'setActualDateForm',
        'actual_date' => 'setActualDate',
        'due_date_will_be_in' => 'setDueDateWillBeIn',
        'negative_slack' => 'setNegativeSlack',
        'positive_slack' => 'setPositiveSlack',
        'epro_grace_period' => 'setEproGracePeriod',
        'forms' => 'setForms',
        'disabled' => 'setDisabled',
        'date_created' => 'setDateCreated',
        'date_modified' => 'setDateModified'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var array<string, string>
     */
    protected static array $getters = [
        'study_key' => 'getStudyKey',
        'interval_id' => 'getIntervalId',
        'interval_name' => 'getIntervalName',
        'interval_description' => 'getIntervalDescription',
        'interval_sequence' => 'getIntervalSequence',
        'interval_group_id' => 'getIntervalGroupId',
        'interval_group_name' => 'getIntervalGroupName',
        'timeline' => 'getTimeline',
        'defined_using_interval' => 'getDefinedUsingInterval',
        'window_calculation_form' => 'getWindowCalculationForm',
        'window_calculation_date' => 'getWindowCalculationDate',
        'actual_date_form' => 'getActualDateForm',
        'actual_date' => 'getActualDate',
        'due_date_will_be_in' => 'getDueDateWillBeIn',
        'negative_slack' => 'getNegativeSlack',
        'positive_slack' => 'getPositiveSlack',
        'epro_grace_period' => 'getEproGracePeriod',
        'forms' => 'getForms',
        'disabled' => 'getDisabled',
        'date_created' => 'getDateCreated',
        'date_modified' => 'getDateModified'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array<string, string>
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array<string, string>
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array<string, string>
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var array
     */
    protected array $container = [];

    /**
     * Constructor
     *
     * @param array $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('study_key', $data ?? [], null);
        $this->setIfExists('interval_id', $data ?? [], null);
        $this->setIfExists('interval_name', $data ?? [], null);
        $this->setIfExists('interval_description', $data ?? [], null);
        $this->setIfExists('interval_sequence', $data ?? [], null);
        $this->setIfExists('interval_group_id', $data ?? [], null);
        $this->setIfExists('interval_group_name', $data ?? [], null);
        $this->setIfExists('timeline', $data ?? [], null);
        $this->setIfExists('defined_using_interval', $data ?? [], null);
        $this->setIfExists('window_calculation_form', $data ?? [], null);
        $this->setIfExists('window_calculation_date', $data ?? [], null);
        $this->setIfExists('actual_date_form', $data ?? [], null);
        $this->setIfExists('actual_date', $data ?? [], null);
        $this->setIfExists('due_date_will_be_in', $data ?? [], null);
        $this->setIfExists('negative_slack', $data ?? [], null);
        $this->setIfExists('positive_slack', $data ?? [], null);
        $this->setIfExists('epro_grace_period', $data ?? [], null);
        $this->setIfExists('forms', $data ?? [], null);
        $this->setIfExists('disabled', $data ?? [], null);
        $this->setIfExists('date_created', $data ?? [], null);
        $this->setIfExists('date_modified', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return string[] invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets study_key
     *
     * @return string|null
     */
    public function getStudyKey(): ?string
    {
        return $this->container['study_key'];
    }

    /**
     * Sets study_key
     *
     * @param string|null $study_key Unique study key
     *
     * @return $this
     */
    public function setStudyKey(?string $study_key): static
    {
        if (is_null($study_key)) {
            throw new InvalidArgumentException('non-nullable study_key cannot be null');
        }
        $this->container['study_key'] = $study_key;

        return $this;
    }

    /**
     * Gets interval_id
     *
     * @return int|null
     */
    public function getIntervalId(): ?int
    {
        return $this->container['interval_id'];
    }

    /**
     * Sets interval_id
     *
     * @param int|null $interval_id Unique system identifier for the interval (visit definition)
     *
     * @return $this
     */
    public function setIntervalId(?int $interval_id): static
    {
        if (is_null($interval_id)) {
            throw new InvalidArgumentException('non-nullable interval_id cannot be null');
        }
        $this->container['interval_id'] = $interval_id;

        return $this;
    }

    /**
     * Gets interval_name
     *
     * @return string|null
     */
    public function getIntervalName(): ?string
    {
        return $this->container['interval_name'];
    }

    /**
     * Sets interval_name
     *
     * @param string|null $interval_name Name of the interval (visit) as defined in the study
     *
     * @return $this
     */
    public function setIntervalName(?string $interval_name): static
    {
        if (is_null($interval_name)) {
            throw new InvalidArgumentException('non-nullable interval_name cannot be null');
        }
        $this->container['interval_name'] = $interval_name;

        return $this;
    }

    /**
     * Gets interval_description
     *
     * @return string|null
     */
    public function getIntervalDescription(): ?string
    {
        return $this->container['interval_description'];
    }

    /**
     * Sets interval_description
     *
     * @param string|null $interval_description Description of the interval (visit)
     *
     * @return $this
     */
    public function setIntervalDescription(?string $interval_description): static
    {
        if (is_null($interval_description)) {
            throw new InvalidArgumentException('non-nullable interval_description cannot be null');
        }
        $this->container['interval_description'] = $interval_description;

        return $this;
    }

    /**
     * Gets interval_sequence
     *
     * @return int|null
     */
    public function getIntervalSequence(): ?int
    {
        return $this->container['interval_sequence'];
    }

    /**
     * Sets interval_sequence
     *
     * @param int|null $interval_sequence Sequence number of the interval in the schedule
     *
     * @return $this
     */
    public function setIntervalSequence(?int $interval_sequence): static
    {
        if (is_null($interval_sequence)) {
            throw new InvalidArgumentException('non-nullable interval_sequence cannot be null');
        }
        $this->container['interval_sequence'] = $interval_sequence;

        return $this;
    }

    /**
     * Gets interval_group_id
     *
     * @return int|null
     */
    public function getIntervalGroupId(): ?int
    {
        return $this->container['interval_group_id'];
    }

    /**
     * Sets interval_group_id
     *
     * @param int|null $interval_group_id Identifier for the interval group (if intervals are grouped)
     *
     * @return $this
     */
    public function setIntervalGroupId(?int $interval_group_id): static
    {
        if (is_null($interval_group_id)) {
            throw new InvalidArgumentException('non-nullable interval_group_id cannot be null');
        }
        $this->container['interval_group_id'] = $interval_group_id;

        return $this;
    }

    /**
     * Gets interval_group_name
     *
     * @return string|null
     */
    public function getIntervalGroupName(): ?string
    {
        return $this->container['interval_group_name'];
    }

    /**
     * Sets interval_group_name
     *
     * @param string|null $interval_group_name Name of the interval group
     *
     * @return $this
     */
    public function setIntervalGroupName(?string $interval_group_name): static
    {
        if (is_null($interval_group_name)) {
            throw new InvalidArgumentException('non-nullable interval_group_name cannot be null');
        }
        $this->container['interval_group_name'] = $interval_group_name;

        return $this;
    }

    /**
     * Gets timeline
     *
     * @return string|null
     */
    public function getTimeline(): ?string
    {
        return $this->container['timeline'];
    }

    /**
     * Sets timeline
     *
     * @param string|null $timeline Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)
     *
     * @return $this
     */
    public function setTimeline(?string $timeline): static
    {
        if (is_null($timeline)) {
            throw new InvalidArgumentException('non-nullable timeline cannot be null');
        }
        $this->container['timeline'] = $timeline;

        return $this;
    }

    /**
     * Gets defined_using_interval
     *
     * @return string|null
     */
    public function getDefinedUsingInterval(): ?string
    {
        return $this->container['defined_using_interval'];
    }

    /**
     * Sets defined_using_interval
     *
     * @param string|null $defined_using_interval Baseline interval used for calculating this interval’s dates
     *
     * @return $this
     */
    public function setDefinedUsingInterval(?string $defined_using_interval): static
    {
        if (is_null($defined_using_interval)) {
            throw new InvalidArgumentException('non-nullable defined_using_interval cannot be null');
        }
        $this->container['defined_using_interval'] = $defined_using_interval;

        return $this;
    }

    /**
     * Gets window_calculation_form
     *
     * @return string|null
     */
    public function getWindowCalculationForm(): ?string
    {
        return $this->container['window_calculation_form'];
    }

    /**
     * Sets window_calculation_form
     *
     * @param string|null $window_calculation_form Baseline form (name) from which the calculation date is taken
     *
     * @return $this
     */
    public function setWindowCalculationForm(?string $window_calculation_form): static
    {
        if (is_null($window_calculation_form)) {
            throw new InvalidArgumentException('non-nullable window_calculation_form cannot be null');
        }
        $this->container['window_calculation_form'] = $window_calculation_form;

        return $this;
    }

    /**
     * Gets window_calculation_date
     *
     * @return string|null
     */
    public function getWindowCalculationDate(): ?string
    {
        return $this->container['window_calculation_date'];
    }

    /**
     * Sets window_calculation_date
     *
     * @param string|null $window_calculation_date Baseline field (variable name) from which the calculation date is taken
     *
     * @return $this
     */
    public function setWindowCalculationDate(?string $window_calculation_date): static
    {
        if (is_null($window_calculation_date)) {
            throw new InvalidArgumentException('non-nullable window_calculation_date cannot be null');
        }
        $this->container['window_calculation_date'] = $window_calculation_date;

        return $this;
    }

    /**
     * Gets actual_date_form
     *
     * @return string|null
     */
    public function getActualDateForm(): ?string
    {
        return $this->container['actual_date_form'];
    }

    /**
     * Sets actual_date_form
     *
     * @param string|null $actual_date_form Form used to capture the actual date for this interval
     *
     * @return $this
     */
    public function setActualDateForm(?string $actual_date_form): static
    {
        if (is_null($actual_date_form)) {
            throw new InvalidArgumentException('non-nullable actual_date_form cannot be null');
        }
        $this->container['actual_date_form'] = $actual_date_form;

        return $this;
    }

    /**
     * Gets actual_date
     *
     * @return string|null
     */
    public function getActualDate(): ?string
    {
        return $this->container['actual_date'];
    }

    /**
     * Sets actual_date
     *
     * @param string|null $actual_date Field (variable name) used to capture the actual date for this interval
     *
     * @return $this
     */
    public function setActualDate(?string $actual_date): static
    {
        if (is_null($actual_date)) {
            throw new InvalidArgumentException('non-nullable actual_date cannot be null');
        }
        $this->container['actual_date'] = $actual_date;

        return $this;
    }

    /**
     * Gets due_date_will_be_in
     *
     * @return int|null
     */
    public function getDueDateWillBeIn(): ?int
    {
        return $this->container['due_date_will_be_in'];
    }

    /**
     * Sets due_date_will_be_in
     *
     * @param int|null $due_date_will_be_in Number of days from the calculation date when the interval is due
     *
     * @return $this
     */
    public function setDueDateWillBeIn(?int $due_date_will_be_in): static
    {
        if (is_null($due_date_will_be_in)) {
            throw new InvalidArgumentException('non-nullable due_date_will_be_in cannot be null');
        }
        $this->container['due_date_will_be_in'] = $due_date_will_be_in;

        return $this;
    }

    /**
     * Gets negative_slack
     *
     * @return int|null
     */
    public function getNegativeSlack(): ?int
    {
        return $this->container['negative_slack'];
    }

    /**
     * Sets negative_slack
     *
     * @param int|null $negative_slack Number of days before the due date that are allowed (negative window)
     *
     * @return $this
     */
    public function setNegativeSlack(?int $negative_slack): static
    {
        if (is_null($negative_slack)) {
            throw new InvalidArgumentException('non-nullable negative_slack cannot be null');
        }
        $this->container['negative_slack'] = $negative_slack;

        return $this;
    }

    /**
     * Gets positive_slack
     *
     * @return int|null
     */
    public function getPositiveSlack(): ?int
    {
        return $this->container['positive_slack'];
    }

    /**
     * Sets positive_slack
     *
     * @param int|null $positive_slack Number of days after the due date that are allowed (positive window)
     *
     * @return $this
     */
    public function setPositiveSlack(?int $positive_slack): static
    {
        if (is_null($positive_slack)) {
            throw new InvalidArgumentException('non-nullable positive_slack cannot be null');
        }
        $this->container['positive_slack'] = $positive_slack;

        return $this;
    }

    /**
     * Gets epro_grace_period
     *
     * @return int|null
     */
    public function getEproGracePeriod(): ?int
    {
        return $this->container['epro_grace_period'];
    }

    /**
     * Sets epro_grace_period
     *
     * @param int|null $epro_grace_period Number of days of grace period for ePRO completion after due date
     *
     * @return $this
     */
    public function setEproGracePeriod(?int $epro_grace_period): static
    {
        if (is_null($epro_grace_period)) {
            throw new InvalidArgumentException('non-nullable epro_grace_period cannot be null');
        }
        $this->container['epro_grace_period'] = $epro_grace_period;

        return $this;
    }

    /**
     * Gets forms
     *
     * @return \OpenAPI\Client\Model\ComponentsSchemasIntervalFormsItem[]|null
     */
    public function getForms(): ?array
    {
        return $this->container['forms'];
    }

    /**
     * Sets forms
     *
     * @param \OpenAPI\Client\Model\ComponentsSchemasIntervalFormsItem[]|null $forms List of forms that are scheduled in this interval
     *
     * @return $this
     */
    public function setForms(?array $forms): static
    {
        if (is_null($forms)) {
            throw new InvalidArgumentException('non-nullable forms cannot be null');
        }
        $this->container['forms'] = $forms;

        return $this;
    }

    /**
     * Gets disabled
     *
     * @return bool|null
     */
    public function getDisabled(): ?bool
    {
        return $this->container['disabled'];
    }

    /**
     * Sets disabled
     *
     * @param bool|null $disabled Whether the interval is soft-deleted (disabled)
     *
     * @return $this
     */
    public function setDisabled(?bool $disabled): static
    {
        if (is_null($disabled)) {
            throw new InvalidArgumentException('non-nullable disabled cannot be null');
        }
        $this->container['disabled'] = $disabled;

        return $this;
    }

    /**
     * Gets date_created
     *
     * @return string|null
     */
    public function getDateCreated(): ?string
    {
        return $this->container['date_created'];
    }

    /**
     * Sets date_created
     *
     * @param string|null $date_created Date when this interval was created
     *
     * @return $this
     */
    public function setDateCreated(?string $date_created): static
    {
        if (is_null($date_created)) {
            throw new InvalidArgumentException('non-nullable date_created cannot be null');
        }
        $this->container['date_created'] = $date_created;

        return $this;
    }

    /**
     * Gets date_modified
     *
     * @return string|null
     */
    public function getDateModified(): ?string
    {
        return $this->container['date_modified'];
    }

    /**
     * Sets date_modified
     *
     * @param string|null $date_modified Date when this interval was last modified
     *
     * @return $this
     */
    public function setDateModified(?string $date_modified): static
    {
        if (is_null($date_modified)) {
            throw new InvalidArgumentException('non-nullable date_modified cannot be null');
        }
        $this->container['date_modified'] = $date_modified;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet(mixed $offset): mixed
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize(): mixed
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue(): string
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


