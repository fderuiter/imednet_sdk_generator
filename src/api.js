// @flow
/* eslint-disable no-use-before-define */
/**
 * Mednet EDC API
 * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
 *
 * The version of the OpenAPI document: 1.3.6
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://edc.prod.imednetapi.com/api/v1/edc".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type Coding = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Coding
     */
    studyKey?: string;
    /**
     * Name of the site associated with the coded data
     * @type {string}
     * @memberof Coding
     */
    siteName?: string;
    /**
     * Site ID associated with the coded data
     * @type {number}
     * @memberof Coding
     */
    siteId?: number;
    /**
     * Subject ID associated with the coded data
     * @type {number}
     * @memberof Coding
     */
    subjectId?: number;
    /**
     * Subject key (display ID) associated with the coded data
     * @type {string}
     * @memberof Coding
     */
    subjectKey?: string;
    /**
     * Form ID where the coded data originates
     * @type {number}
     * @memberof Coding
     */
    formId?: number;
    /**
     * Name of the form where the coded data originates
     * @type {string}
     * @memberof Coding
     */
    formName?: string;
    /**
     * Form key where the coded data originates
     * @type {string}
     * @memberof Coding
     */
    formKey?: string;
    /**
     * Revision number of the coding entry
     * @type {number}
     * @memberof Coding
     */
    revision?: number;
    /**
     * Record ID associated with the coded data
     * @type {number}
     * @memberof Coding
     */
    recordId?: number;
    /**
     * Variable name (field) that was coded
     * @type {string}
     * @memberof Coding
     */
    variable?: string;
    /**
     * Original value entered that required coding
     * @type {string}
     * @memberof Coding
     */
    value?: string;
    /**
     * Mednet coding ID
     * @type {number}
     * @memberof Coding
     */
    codingId?: number;
    /**
     * Standardized code assigned (e.g., dictionary term)
     * @type {string}
     * @memberof Coding
     */
    code?: string;
    /**
     * Name of the user who performed the coding
     * @type {string}
     * @memberof Coding
     */
    codedBy?: string;
    /**
     * Reason for coding or any notes on changes
     * @type {string}
     * @memberof Coding
     */
    reason?: string;
    /**
     * Name of the dictionary used (e.g., MedDRA)
     * @type {string}
     * @memberof Coding
     */
    dictionaryName?: string;
    /**
     * Version of the dictionary used
     * @type {string}
     * @memberof Coding
     */
    dictionaryVersion?: string;
    /**
     * Date when the coding was performed
     * @type {string}
     * @memberof Coding
     */
    dateCoded?: string;
}

/**
 * 
 * @export
 */
export type CodingList = {
    /**
     * 
     * @type {Metadata}
     * @memberof CodingList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof CodingList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Coding>}
     * @memberof CodingList
     */
    data?: Array<Coding>;
}

/**
 * 
 * @export
 */
export type ComponentsSchemasIntervalFormsItem = {
    /**
     * Form ID scheduled in the interval
     * @type {number}
     * @memberof ComponentsSchemasIntervalFormsItem
     */
    formId?: number;
    /**
     * Form key scheduled in the interval
     * @type {string}
     * @memberof ComponentsSchemasIntervalFormsItem
     */
    formKey?: string;
    /**
     * Form name scheduled in the interval
     * @type {string}
     * @memberof ComponentsSchemasIntervalFormsItem
     */
    formName?: string;
}

/**
 * Error details if an error occurred
 * @export
 */
export type ComponentsSchemasMetadataError = {
    [key: string]: AnyType | any;

    /**
     * Error message describing the issue
     * @type {string}
     * @memberof ComponentsSchemasMetadataError
     */
    message?: string;
}

/**
 * 
 * @export
 */
export type ComponentsSchemasRecordCreateRequestItem = {
    /**
     * Form key identifying the eCRF to create or update
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    formKey: string;
    /**
     * Form ID identifying the eCRF to create or update (alternative to formKey)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    formId?: number;
    /**
     * Name of the site where the record should be created (for new subject registration)
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    siteName?: string;
    /**
     * Site ID for the record (alternative to siteName)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    siteId?: number;
    /**
     * Subject identifier (display ID) for which to create or update the record
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    subjectKey?: string;
    /**
     * Subject ID for which to create or update the record (alternative to subjectKey)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    subjectId?: number;
    /**
     * Subject OID for which to create or update the record (alternative to subjectKey)
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    subjectOid?: string;
    /**
     * Name of the interval (visit) for a scheduled record update
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    intervalName?: string;
    /**
     * Interval ID for a scheduled record update (alternative to intervalName)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    intervalId?: number;
    /**
     * Record ID for updating an existing unscheduled record (if applicable)
     * @type {number}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    recordId?: number;
    /**
     * Record OID for updating an existing unscheduled record (if applicable)
     * @type {string}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    recordOid?: string;
    /**
     * Key-value pairs of field names and values for the record data
     * @type {{ [key: string]: AnyType; }}
     * @memberof ComponentsSchemasRecordCreateRequestItem
     */
    data: { [key: string]: AnyType; };
}

/**
 * 
 * @export
 */
export type Form = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Form
     */
    studyKey?: string;
    /**
     * Mednet Form ID
     * @type {number}
     * @memberof Form
     */
    formId?: number;
    /**
     * User-defined form key
     * @type {string}
     * @memberof Form
     */
    formKey?: string;
    /**
     * Name of the form (eCRF)
     * @type {string}
     * @memberof Form
     */
    formName?: string;
    /**
     * Type of the form (e.g., Subject or Site)
     * @type {string}
     * @memberof Form
     */
    formType?: string;
    /**
     * Number of modifications (revisions) of the form metadata
     * @type {number}
     * @memberof Form
     */
    revision?: number;
    /**
     * Whether the form has an embedded log
     * @type {boolean}
     * @memberof Form
     */
    embeddedLog?: boolean;
    /**
     * Whether the form enforces record ownership
     * @type {boolean}
     * @memberof Form
     */
    enforceOwnership?: boolean;
    /**
     * Whether the form requires a user agreement
     * @type {boolean}
     * @memberof Form
     */
    userAgreement?: boolean;
    /**
     * Whether the form is marked as a subject record report
     * @type {boolean}
     * @memberof Form
     */
    subjectRecordReport?: boolean;
    /**
     * Whether the form is included in unscheduled visits
     * @type {boolean}
     * @memberof Form
     */
    unscheduledVisit?: boolean;
    /**
     * Whether the form is included in Other Forms category
     * @type {boolean}
     * @memberof Form
     */
    otherForms?: boolean;
    /**
     * Whether the form is an ePRO (electronic patient reported outcome) form
     * @type {boolean}
     * @memberof Form
     */
    eproForm?: boolean;
    /**
     * Whether the form allows copying of data
     * @type {boolean}
     * @memberof Form
     */
    allowCopy?: boolean;
    /**
     * Whether the form is soft-deleted (disabled)
     * @type {boolean}
     * @memberof Form
     */
    disabled?: boolean;
    /**
     * Date when this form was created
     * @type {string}
     * @memberof Form
     */
    dateCreated?: string;
    /**
     * Date when this form was last modified
     * @type {string}
     * @memberof Form
     */
    dateModified?: string;
}

/**
 * 
 * @export
 */
export type FormList = {
    /**
     * 
     * @type {Metadata}
     * @memberof FormList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof FormList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Form>}
     * @memberof FormList
     */
    data?: Array<Form>;
}

/**
 * 
 * @export
 */
export type InlineObject = {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject
     */
    metadata?: Metadata;
}

/**
 * 
 * @export
 */
export type InlineObject1 = {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject1
     */
    metadata?: Metadata;
}

/**
 * 
 * @export
 */
export type InlineObject2 = {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject2
     */
    metadata?: Metadata;
}

/**
 * 
 * @export
 */
export type InlineObject3 = {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject3
     */
    metadata?: Metadata;
}

/**
 * 
 * @export
 */
export type InlineObject4 = {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject4
     */
    metadata?: Metadata;
}

/**
 * 
 * @export
 */
export type InlineObject5 = {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineObject5
     */
    metadata?: Metadata;
}

/**
 * 
 * @export
 */
export type Interval = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Interval
     */
    studyKey?: string;
    /**
     * Unique system identifier for the interval (visit definition)
     * @type {number}
     * @memberof Interval
     */
    intervalId?: number;
    /**
     * Name of the interval (visit) as defined in the study
     * @type {string}
     * @memberof Interval
     */
    intervalName?: string;
    /**
     * Description of the interval (visit)
     * @type {string}
     * @memberof Interval
     */
    intervalDescription?: string;
    /**
     * Sequence number of the interval in the schedule
     * @type {number}
     * @memberof Interval
     */
    intervalSequence?: number;
    /**
     * Identifier for the interval group (if intervals are grouped)
     * @type {number}
     * @memberof Interval
     */
    intervalGroupId?: number;
    /**
     * Name of the interval group
     * @type {string}
     * @memberof Interval
     */
    intervalGroupName?: string;
    /**
     * Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)
     * @type {string}
     * @memberof Interval
     */
    timeline?: string;
    /**
     * Baseline interval used for calculating this interval’s dates
     * @type {string}
     * @memberof Interval
     */
    definedUsingInterval?: string;
    /**
     * Baseline form (name) from which the calculation date is taken
     * @type {string}
     * @memberof Interval
     */
    windowCalculationForm?: string;
    /**
     * Baseline field (variable name) from which the calculation date is taken
     * @type {string}
     * @memberof Interval
     */
    windowCalculationDate?: string;
    /**
     * Form used to capture the actual date for this interval
     * @type {string}
     * @memberof Interval
     */
    actualDateForm?: string;
    /**
     * Field (variable name) used to capture the actual date for this interval
     * @type {string}
     * @memberof Interval
     */
    actualDate?: string;
    /**
     * Number of days from the calculation date when the interval is due
     * @type {number}
     * @memberof Interval
     */
    dueDateWillBeIn?: number;
    /**
     * Number of days before the due date that are allowed (negative window)
     * @type {number}
     * @memberof Interval
     */
    negativeSlack?: number;
    /**
     * Number of days after the due date that are allowed (positive window)
     * @type {number}
     * @memberof Interval
     */
    positiveSlack?: number;
    /**
     * Number of days of grace period for ePRO completion after due date
     * @type {number}
     * @memberof Interval
     */
    eproGracePeriod?: number;
    /**
     * List of forms that are scheduled in this interval
     * @type {Array<ComponentsSchemasIntervalFormsItem>}
     * @memberof Interval
     */
    forms?: Array<ComponentsSchemasIntervalFormsItem>;
    /**
     * Whether the interval is soft-deleted (disabled)
     * @type {boolean}
     * @memberof Interval
     */
    disabled?: boolean;
    /**
     * Date when this interval was created
     * @type {string}
     * @memberof Interval
     */
    dateCreated?: string;
    /**
     * Date when this interval was last modified
     * @type {string}
     * @memberof Interval
     */
    dateModified?: string;
}

/**
 * 
 * @export
 */
export type IntervalList = {
    /**
     * 
     * @type {Metadata}
     * @memberof IntervalList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof IntervalList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Interval>}
     * @memberof IntervalList
     */
    data?: Array<Interval>;
}

/**
 * 
 * @export
 */
export type Job = {
    /**
     * Unique job identifier
     * @type {string}
     * @memberof Job
     */
    jobId?: string;
    /**
     * Batch ID associated with the job (useful for linking with record creation requests)
     * @type {string}
     * @memberof Job
     */
    batchId?: string;
    /**
     * State of the job (e.g., completed, pending)
     * @type {string}
     * @memberof Job
     */
    state?: string;
    /**
     * Timestamp when the job was created
     * @type {string}
     * @memberof Job
     */
    dateCreated?: string;
    /**
     * Timestamp when the job started processing
     * @type {string}
     * @memberof Job
     */
    dateStarted?: string;
    /**
     * Timestamp when the job finished processing
     * @type {string}
     * @memberof Job
     */
    dateFinished?: string;
}

/**
 * 
 * @export
 */
export type Keyword = {
    /**
     * Name of the keyword
     * @type {string}
     * @memberof Keyword
     */
    keywordName?: string;
    /**
     * Key of the keyword (short code)
     * @type {string}
     * @memberof Keyword
     */
    keywordKey?: string;
    /**
     * Internal keyword ID
     * @type {number}
     * @memberof Keyword
     */
    keywordId?: number;
    /**
     * Date when this keyword was added
     * @type {string}
     * @memberof Keyword
     */
    dateAdded?: string;
}

/**
 * 
 * @export
 */
export type Metadata = {
    /**
     * HTTP status of the response (e.g., OK or ERROR)
     * @type {string}
     * @memberof Metadata
     */
    status?: string;
    /**
     * HTTP method of the request
     * @type {string}
     * @memberof Metadata
     */
    method?: string;
    /**
     * Requested URI path
     * @type {string}
     * @memberof Metadata
     */
    path?: string;
    /**
     * Timestamp when response was generated
     * @type {Date}
     * @memberof Metadata
     */
    timestamp?: Date;
    /**
     * 
     * @type {ComponentsSchemasMetadataError}
     * @memberof Metadata
     */
    error?: ComponentsSchemasMetadataError;
}

/**
 * 
 * @export
 */
export type Pagination = {
    /**
     * Current index page returned
     * @type {number}
     * @memberof Pagination
     */
    currentPage?: number;
    /**
     * Number of items per page returned
     * @type {number}
     * @memberof Pagination
     */
    size?: number;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof Pagination
     */
    totalPages?: number;
    /**
     * Total number of elements (items) available
     * @type {number}
     * @memberof Pagination
     */
    totalElements?: number;
    /**
     * 
     * @type {Array<Sort>}
     * @memberof Pagination
     */
    sort?: Array<Sort>;
}

/**
 * 
 * @export
 */
export type Query = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Query
     */
    studyKey?: string;
    /**
     * Mednet subject ID associated with the query (if applicable)
     * @type {number}
     * @memberof Query
     */
    subjectId?: number;
    /**
     * Client-assigned subject OID (if applicable)
     * @type {string}
     * @memberof Query
     */
    subjectOid?: string;
    /**
     * Category/type of the query (e.g., subject, record, question)
     * @type {string}
     * @memberof Query
     */
    annotationType?: string;
    /**
     * Unique system identifier for the query
     * @type {number}
     * @memberof Query
     */
    annotationId?: number;
    /**
     * System text identifier for the query type/location (subject, record, question)
     * @type {string}
     * @memberof Query
     */
    type?: string;
    /**
     * Description of the query (e.g., reason or context)
     * @type {string}
     * @memberof Query
     */
    description?: string;
    /**
     * Record ID associated with the query (if applicable)
     * @type {number}
     * @memberof Query
     */
    recordId?: number;
    /**
     * Variable name (field) associated with the query (if applicable)
     * @type {string}
     * @memberof Query
     */
    variable?: string;
    /**
     * Subject display ID associated with the query (if applicable)
     * @type {string}
     * @memberof Query
     */
    subjectKey?: string;
    /**
     * Date when the query was created
     * @type {string}
     * @memberof Query
     */
    dateCreated?: string;
    /**
     * Date when the query was last modified
     * @type {string}
     * @memberof Query
     */
    dateModified?: string;
    /**
     * History of comments/actions on the query
     * @type {Array<QueryComment>}
     * @memberof Query
     */
    queryComments?: Array<QueryComment>;
}

/**
 * 
 * @export
 */
export type QueryComment = {
    /**
     * Sequence number of the comment/action in the query history
     * @type {number}
     * @memberof QueryComment
     */
    sequence?: number;
    /**
     * Status of the query after this comment (e.g., Open, Closed)
     * @type {string}
     * @memberof QueryComment
     */
    annotationStatus?: string;
    /**
     * Username of the user who made the comment or action
     * @type {string}
     * @memberof QueryComment
     */
    user?: string;
    /**
     * Text of the comment
     * @type {string}
     * @memberof QueryComment
     */
    comment?: string;
    /**
     * Whether the query was marked closed at this step
     * @type {boolean}
     * @memberof QueryComment
     */
    closed?: boolean;
    /**
     * Date of the comment or action
     * @type {string}
     * @memberof QueryComment
     */
    _date?: string;
}

/**
 * 
 * @export
 */
export type QueryList = {
    /**
     * 
     * @type {Metadata}
     * @memberof QueryList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof QueryList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Query>}
     * @memberof QueryList
     */
    data?: Array<Query>;
}

/**
 * 
 * @export
 */
export type Record = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Record
     */
    studyKey?: string;
    /**
     * Interval ID (visit definition) that this record is associated with
     * @type {number}
     * @memberof Record
     */
    intervalId?: number;
    /**
     * Form ID of the form this record instance belongs to
     * @type {number}
     * @memberof Record
     */
    formId?: number;
    /**
     * Form key of the form for this record instance
     * @type {string}
     * @memberof Record
     */
    formKey?: string;
    /**
     * Site ID associated with the record
     * @type {number}
     * @memberof Record
     */
    siteId?: number;
    /**
     * Unique record ID
     * @type {number}
     * @memberof Record
     */
    recordId?: number;
    /**
     * Client-assigned record OID
     * @type {string}
     * @memberof Record
     */
    recordOid?: string;
    /**
     * Type of record (e.g., SUBJECT for subject-related forms)
     * @type {string}
     * @memberof Record
     */
    recordType?: string;
    /**
     * Current status of the record (e.g., Record Incomplete, Record Complete)
     * @type {string}
     * @memberof Record
     */
    recordStatus?: string;
    /**
     * Whether the record is marked as deleted
     * @type {boolean}
     * @memberof Record
     */
    deleted?: boolean;
    /**
     * Date when this record was created
     * @type {string}
     * @memberof Record
     */
    dateCreated?: string;
    /**
     * Date when this record was last modified
     * @type {string}
     * @memberof Record
     */
    dateModified?: string;
    /**
     * Mednet subject ID that this record is associated with
     * @type {number}
     * @memberof Record
     */
    subjectId?: number;
    /**
     * Client-assigned subject OID for the subject this record is associated with
     * @type {string}
     * @memberof Record
     */
    subjectOid?: string;
    /**
     * Subject display ID that this record is associated with
     * @type {string}
     * @memberof Record
     */
    subjectKey?: string;
    /**
     * Visit instance ID that this record is associated with (if applicable)
     * @type {number}
     * @memberof Record
     */
    visitId?: number;
    /**
     * Record ID of the parent record if this record is a subrecord (if applicable)
     * @type {number}
     * @memberof Record
     */
    parentRecordId?: number;
    /**
     * List of keywords associated with the record
     * @type {Array<Keyword>}
     * @memberof Record
     */
    keywords?: Array<Keyword>;
    /**
     * Data fields and values captured in this record. The structure is dynamic, with keys corresponding to variable names.
     * @type {{ [key: string]: AnyType; }}
     * @memberof Record
     */
    recordData?: { [key: string]: AnyType; };
}

/**
 * 
 * @export
 */
export type RecordJobStatus = {
    /**
     * Unique job identifier
     * @type {string}
     * @memberof RecordJobStatus
     */
    jobId?: string;
    /**
     * Batch ID used to track the job (identical to jobId in most cases)
     * @type {string}
     * @memberof RecordJobStatus
     */
    batchId?: string;
    /**
     * Current state of the job (e.g., created, completed)
     * @type {string}
     * @memberof RecordJobStatus
     */
    state?: string;
}

/**
 * 
 * @export
 */
export type RecordList = {
    /**
     * 
     * @type {Metadata}
     * @memberof RecordList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof RecordList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Record>}
     * @memberof RecordList
     */
    data?: Array<Record>;
}

/**
 * 
 * @export
 */
export type RecordRevision = {
    /**
     * Unique study key
     * @type {string}
     * @memberof RecordRevision
     */
    studyKey?: string;
    /**
     * Unique system identifier for the record revision
     * @type {number}
     * @memberof RecordRevision
     */
    recordRevisionId?: number;
    /**
     * Unique system identifier of the related record
     * @type {number}
     * @memberof RecordRevision
     */
    recordId?: number;
    /**
     * Client-assigned record OID (if any)
     * @type {string}
     * @memberof RecordRevision
     */
    recordOid?: string;
    /**
     * Revision number of the record (version of the record status)
     * @type {number}
     * @memberof RecordRevision
     */
    recordRevision?: number;
    /**
     * Revision number of the data within the record
     * @type {number}
     * @memberof RecordRevision
     */
    dataRevision?: number;
    /**
     * Status of the record at this revision (user-defined status label)
     * @type {string}
     * @memberof RecordRevision
     */
    recordStatus?: string;
    /**
     * Mednet subject ID related to the record
     * @type {number}
     * @memberof RecordRevision
     */
    subjectId?: number;
    /**
     * Client-assigned subject OID related to the record
     * @type {string}
     * @memberof RecordRevision
     */
    subjectOid?: string;
    /**
     * Subject display ID related to the record
     * @type {string}
     * @memberof RecordRevision
     */
    subjectKey?: string;
    /**
     * Site ID related to the record
     * @type {number}
     * @memberof RecordRevision
     */
    siteId?: number;
    /**
     * Form key of the form that the record belongs to
     * @type {string}
     * @memberof RecordRevision
     */
    formKey?: string;
    /**
     * Interval ID (visit definition) related to the record
     * @type {number}
     * @memberof RecordRevision
     */
    intervalId?: number;
    /**
     * Role name of the user who saved the record revision
     * @type {string}
     * @memberof RecordRevision
     */
    role?: string;
    /**
     * Username of the user who saved the record revision
     * @type {string}
     * @memberof RecordRevision
     */
    user?: string;
    /**
     * Reason for change, if provided (for audit trail)
     * @type {string}
     * @memberof RecordRevision
     */
    reasonForChange?: string;
    /**
     * Whether the record was deleted in this revision
     * @type {boolean}
     * @memberof RecordRevision
     */
    deleted?: boolean;
    /**
     * Date when this record revision was created
     * @type {string}
     * @memberof RecordRevision
     */
    dateCreated?: string;
}

/**
 * 
 * @export
 */
export type RecordRevisionList = {
    /**
     * 
     * @type {Metadata}
     * @memberof RecordRevisionList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof RecordRevisionList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<RecordRevision>}
     * @memberof RecordRevisionList
     */
    data?: Array<RecordRevision>;
}

/**
 * 
 * @export
 */
export type Role = {
    /**
     * Timestamp when the role assignment was created (as [year, month, day, hour, minute, second, nanosecond])
     * @type {Array<number>}
     * @memberof Role
     */
    dateCreated?: Array<number>;
    /**
     * Timestamp when the role assignment was last modified
     * @type {Array<number>}
     * @memberof Role
     */
    dateModified?: Array<number>;
    /**
     * Unique role ID (UUID)
     * @type {string}
     * @memberof Role
     */
    roleId?: string;
    /**
     * Community ID or level associated with the role
     * @type {number}
     * @memberof Role
     */
    communityId?: number;
    /**
     * Name of the role
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * Description of the role
     * @type {string}
     * @memberof Role
     */
    description?: string;
    /**
     * Role level or hierarchy
     * @type {number}
     * @memberof Role
     */
    level?: number;
    /**
     * Role type/category
     * @type {string}
     * @memberof Role
     */
    type?: string;
    /**
     * Whether the role is inactive
     * @type {boolean}
     * @memberof Role
     */
    inactive?: boolean;
}

/**
 * 
 * @export
 */
export type Site = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Site
     */
    studyKey?: string;
    /**
     * Unique site ID
     * @type {number}
     * @memberof Site
     */
    siteId?: number;
    /**
     * Name of the site
     * @type {string}
     * @memberof Site
     */
    siteName?: string;
    /**
     * Enrollment status of the site
     * @type {string}
     * @memberof Site
     */
    siteEnrollmentStatus?: string;
    /**
     * Date when this site was created
     * @type {string}
     * @memberof Site
     */
    dateCreated?: string;
    /**
     * Date when this site was last modified
     * @type {string}
     * @memberof Site
     */
    dateModified?: string;
}

/**
 * 
 * @export
 */
export type SiteList = {
    /**
     * 
     * @type {Metadata}
     * @memberof SiteList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof SiteList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Site>}
     * @memberof SiteList
     */
    data?: Array<Site>;
}


            export type SortDirectionEnum = 'ASC' | 'DESC';
/**
 * 
 * @export
 */
export type Sort = {
    /**
     * Name of the property by which the result is sorted
     * @type {string}
     * @memberof Sort
     */
    property?: string;
    /**
     * Sort direction (ASC or DESC)
     * @type {string}
     * @memberof Sort
     */
    direction?: SortDirectionEnum;
}

/**
 * 
 * @export
 */
export type Study = {
    /**
     * Sponsor key that this study belongs to
     * @type {string}
     * @memberof Study
     */
    sponsorKey?: string;
    /**
     * Unique study key
     * @type {string}
     * @memberof Study
     */
    studyKey?: string;
    /**
     * Mednet study ID (internal numeric identifier)
     * @type {number}
     * @memberof Study
     */
    studyId?: number;
    /**
     * Name of the study
     * @type {string}
     * @memberof Study
     */
    studyName?: string;
    /**
     * Description of the study
     * @type {string}
     * @memberof Study
     */
    studyDescription?: string;
    /**
     * Type of study (e.g., STUDY)
     * @type {string}
     * @memberof Study
     */
    studyType?: string;
    /**
     * Date when the study record was created
     * @type {string}
     * @memberof Study
     */
    dateCreated?: string;
    /**
     * Date when the study record was last modified
     * @type {string}
     * @memberof Study
     */
    dateModified?: string;
}

/**
 * 
 * @export
 */
export type StudyList = {
    /**
     * 
     * @type {Metadata}
     * @memberof StudyList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof StudyList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Study>}
     * @memberof StudyList
     */
    data?: Array<Study>;
}

/**
 * 
 * @export
 */
export type Subject = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Subject
     */
    studyKey?: string;
    /**
     * Mednet subject ID (internal numeric ID)
     * @type {number}
     * @memberof Subject
     */
    subjectId?: number;
    /**
     * Client-assigned subject object identifier (OID)
     * @type {string}
     * @memberof Subject
     */
    subjectOid?: string;
    /**
     * Protocol-assigned subject identifier (display ID)
     * @type {string}
     * @memberof Subject
     */
    subjectKey?: string;
    /**
     * Current status of the subject (e.g., Enrolled)
     * @type {string}
     * @memberof Subject
     */
    subjectStatus?: string;
    /**
     * Mednet site ID the subject is associated with
     * @type {number}
     * @memberof Subject
     */
    siteId?: number;
    /**
     * Name of the site the subject is associated with
     * @type {string}
     * @memberof Subject
     */
    siteName?: string;
    /**
     * Whether the subject is marked as deleted
     * @type {boolean}
     * @memberof Subject
     */
    deleted?: boolean;
    /**
     * Subject’s enrollment start date
     * @type {string}
     * @memberof Subject
     */
    enrollmentStartDate?: string;
    /**
     * Date when this subject record was created
     * @type {string}
     * @memberof Subject
     */
    dateCreated?: string;
    /**
     * Date when this subject record was last modified
     * @type {string}
     * @memberof Subject
     */
    dateModified?: string;
    /**
     * List of keywords associated with the subject
     * @type {Array<Keyword>}
     * @memberof Subject
     */
    keywords?: Array<Keyword>;
}

/**
 * 
 * @export
 */
export type SubjectList = {
    /**
     * 
     * @type {Metadata}
     * @memberof SubjectList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof SubjectList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Subject>}
     * @memberof SubjectList
     */
    data?: Array<Subject>;
}

/**
 * 
 * @export
 */
export type User = {
    /**
     * Unique user ID (UUID)
     * @type {string}
     * @memberof User
     */
    userId?: string;
    /**
     * User login name
     * @type {string}
     * @memberof User
     */
    login?: string;
    /**
     * User first name
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * User last name
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * User email address
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Whether the user is active in the given study
     * @type {boolean}
     * @memberof User
     */
    userActiveInStudy?: boolean;
    /**
     * Roles that the user has in the study
     * @type {Array<Role>}
     * @memberof User
     */
    roles?: Array<Role>;
}

/**
 * 
 * @export
 */
export type UserList = {
    /**
     * 
     * @type {Metadata}
     * @memberof UserList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof UserList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList
     */
    data?: Array<User>;
}


            export type VariableVariableTypeEnum = 'TEXT' | 'TEXTAREA' | 'RADIO' | 'CHECKBOX' | 'DROPDOWN' | 'DATE' | 'NUMBER';
/**
 * 
 * @export
 */
export type Variable = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Variable
     */
    studyKey?: string;
    /**
     * Mednet variable ID
     * @type {number}
     * @memberof Variable
     */
    variableId?: number;
    /**
     * Type of the variable (field type), e.g., RADIO, TEXT, etc.
     * @type {string}
     * @memberof Variable
     */
    variableType?: VariableVariableTypeEnum;
    /**
     * Name of the variable (question text or label)
     * @type {string}
     * @memberof Variable
     */
    variableName?: string;
    /**
     * Sequence of the variable on the form
     * @type {number}
     * @memberof Variable
     */
    sequence?: number;
    /**
     * Number of modifications of the variable (via form metadata revisions)
     * @type {number}
     * @memberof Variable
     */
    revision?: number;
    /**
     * Whether the variable is marked as disabled (deleted)
     * @type {boolean}
     * @memberof Variable
     */
    disabled?: boolean;
    /**
     * Date when this variable was created
     * @type {string}
     * @memberof Variable
     */
    dateCreated?: string;
    /**
     * Date when this variable was last modified
     * @type {string}
     * @memberof Variable
     */
    dateModified?: string;
    /**
     * ID of the form that this variable belongs to
     * @type {number}
     * @memberof Variable
     */
    formId?: number;
    /**
     * Client-assigned variable OID
     * @type {string}
     * @memberof Variable
     */
    variableOid?: string;
    /**
     * Whether the variable is marked as deleted
     * @type {boolean}
     * @memberof Variable
     */
    deleted?: boolean;
    /**
     * Form key of the form that this variable belongs to
     * @type {string}
     * @memberof Variable
     */
    formKey?: string;
    /**
     * Name of the form that this variable belongs to
     * @type {string}
     * @memberof Variable
     */
    formName?: string;
    /**
     * User-defined identifier (field name) for the variable
     * @type {string}
     * @memberof Variable
     */
    label?: string;
    /**
     * Whether the variable is flagged as blinded (hidden in certain contexts)
     * @type {boolean}
     * @memberof Variable
     */
    blinded?: boolean;
}

/**
 * 
 * @export
 */
export type VariableList = {
    /**
     * 
     * @type {Metadata}
     * @memberof VariableList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof VariableList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof VariableList
     */
    data?: Array<Variable>;
}

/**
 * 
 * @export
 */
export type Visit = {
    /**
     * Unique study key
     * @type {string}
     * @memberof Visit
     */
    studyKey?: string;
    /**
     * Unique system identifier for the subject visit instance
     * @type {number}
     * @memberof Visit
     */
    visitId?: number;
    /**
     * Unique system identifier of the interval definition for this visit
     * @type {number}
     * @memberof Visit
     */
    intervalId?: number;
    /**
     * Name of the interval (visit) for this visit instance
     * @type {string}
     * @memberof Visit
     */
    intervalName?: string;
    /**
     * Mednet subject ID of the subject
     * @type {number}
     * @memberof Visit
     */
    subjectId?: number;
    /**
     * Protocol-assigned subject identifier
     * @type {string}
     * @memberof Visit
     */
    subjectKey?: string;
    /**
     * Start date of the visit window (in YYYY-MM-DD format)
     * @type {string}
     * @memberof Visit
     */
    startDate?: string;
    /**
     * End date of the visit window (in YYYY-MM-DD format)
     * @type {string}
     * @memberof Visit
     */
    endDate?: string;
    /**
     * Due date of the visit (in YYYY-MM-DD format), if applicable
     * @type {string}
     * @memberof Visit
     */
    dueDate?: string;
    /**
     * Actual date the visit took place (in YYYY-MM-DD format)
     * @type {string}
     * @memberof Visit
     */
    visitDate?: string;
    /**
     * Name of the form used to capture the actual visit date
     * @type {string}
     * @memberof Visit
     */
    visitDateForm?: string;
    /**
     * Variable name of the field capturing the actual visit date
     * @type {string}
     * @memberof Visit
     */
    visitDateQuestion?: string;
    /**
     * Whether the visit instance is marked as deleted
     * @type {boolean}
     * @memberof Visit
     */
    deleted?: boolean;
    /**
     * Date when this visit record was created
     * @type {string}
     * @memberof Visit
     */
    dateCreated?: string;
    /**
     * Date when this visit record was last modified
     * @type {string}
     * @memberof Visit
     */
    dateModified?: string;
}

/**
 * 
 * @export
 */
export type VisitList = {
    /**
     * 
     * @type {Metadata}
     * @memberof VisitList
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Pagination}
     * @memberof VisitList
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Visit>}
     * @memberof VisitList
     */
    data?: Array<Visit>;
}



/**
 * AdministrationApi - fetch parameter creator
 * @export
 */
export const AdministrationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List users and their roles in a study
         * @throws {RequiredError}
         */
        listUsers(studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listUsers.');
            }
            const localVarPath = `/studies/{studyKey}/users`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['includeInactive'] = ((includeInactive:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AdministrationApiType = { 
    listUsers(studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options?: RequestOptions): Promise<UserList>,
}

/**
 * AdministrationApi - factory function to inject configuration 
 * @export
 */
export const AdministrationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AdministrationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List users and their roles in a study
         * @throws {RequiredError}
         */
        listUsers(studyKey: string, page?: number, size?: number, sort?: string, includeInactive?: boolean, options?: RequestOptions = {}): Promise<UserList> {
            const localVarFetchArgs = AdministrationApiFetchParamCreator(configuration).listUsers(studyKey, page, size, sort, includeInactive, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CodingsApi - fetch parameter creator
 * @export
 */
export const CodingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List coding activities in a study
         * @throws {RequiredError}
         */
        listCodings(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listCodings.');
            }
            const localVarPath = `/studies/{studyKey}/codings`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CodingsApiType = { 
    listCodings(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<CodingList>,
}

/**
 * CodingsApi - factory function to inject configuration 
 * @export
 */
export const CodingsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CodingsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List coding activities in a study
         * @throws {RequiredError}
         */
        listCodings(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<CodingList> {
            const localVarFetchArgs = CodingsApiFetchParamCreator(configuration).listCodings(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FormsApi - fetch parameter creator
 * @export
 */
export const FormsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List forms in a study
         * @throws {RequiredError}
         */
        listForms(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listForms.');
            }
            const localVarPath = `/studies/{studyKey}/forms`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FormsApiType = { 
    listForms(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<FormList>,
}

/**
 * FormsApi - factory function to inject configuration 
 * @export
 */
export const FormsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FormsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List forms in a study
         * @throws {RequiredError}
         */
        listForms(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<FormList> {
            const localVarFetchArgs = FormsApiFetchParamCreator(configuration).listForms(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * IntervalsApi - fetch parameter creator
 * @export
 */
export const IntervalsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List intervals (visit definitions) in a study
         * @throws {RequiredError}
         */
        listIntervals(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listIntervals.');
            }
            const localVarPath = `/studies/{studyKey}/intervals`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type IntervalsApiType = { 
    listIntervals(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<IntervalList>,
}

/**
 * IntervalsApi - factory function to inject configuration 
 * @export
 */
export const IntervalsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): IntervalsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List intervals (visit definitions) in a study
         * @throws {RequiredError}
         */
        listIntervals(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<IntervalList> {
            const localVarFetchArgs = IntervalsApiFetchParamCreator(configuration).listIntervals(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * JobsApi - fetch parameter creator
 * @export
 */
export const JobsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve job status by batch ID
         * @throws {RequiredError}
         */
        getJobStatus(studyKey: string, batchId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling getJobStatus.');
            }
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling getJobStatus.');
            }
            const localVarPath = `/studies/{studyKey}/jobs/{batchId}`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)))
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type JobsApiType = { 
    getJobStatus(studyKey: string, batchId: string, options?: RequestOptions): Promise<Job>,
}

/**
 * JobsApi - factory function to inject configuration 
 * @export
 */
export const JobsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): JobsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Retrieve job status by batch ID
         * @throws {RequiredError}
         */
        getJobStatus(studyKey: string, batchId: string, options?: RequestOptions = {}): Promise<Job> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobStatus(studyKey, batchId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export const QueriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List data queries in a study
         * @throws {RequiredError}
         */
        listQueries(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listQueries.');
            }
            const localVarPath = `/studies/{studyKey}/queries`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type QueriesApiType = { 
    listQueries(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<QueryList>,
}

/**
 * QueriesApi - factory function to inject configuration 
 * @export
 */
export const QueriesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): QueriesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List data queries in a study
         * @throws {RequiredError}
         */
        listQueries(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<QueryList> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).listQueries(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RecordRevisionsApi - fetch parameter creator
 * @export
 */
export const RecordRevisionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List record revisions (audit trail entries) in a study
         * @throws {RequiredError}
         */
        listRecordRevisions(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listRecordRevisions.');
            }
            const localVarPath = `/studies/{studyKey}/recordRevisions`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RecordRevisionsApiType = { 
    listRecordRevisions(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<RecordRevisionList>,
}

/**
 * RecordRevisionsApi - factory function to inject configuration 
 * @export
 */
export const RecordRevisionsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RecordRevisionsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List record revisions (audit trail entries) in a study
         * @throws {RequiredError}
         */
        listRecordRevisions(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<RecordRevisionList> {
            const localVarFetchArgs = RecordRevisionsApiFetchParamCreator(configuration).listRecordRevisions(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RecordsApi - fetch parameter creator
 * @export
 */
export const RecordsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new record or update subject/record data
         * @throws {RequiredError}
         */
        createRecords(studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling createRecords.');
            }
            // verify required parameter 'componentsSchemasRecordCreateRequestItem' is not null or undefined
            if (componentsSchemasRecordCreateRequestItem === null || componentsSchemasRecordCreateRequestItem === undefined) {
                throw new RequiredError('componentsSchemasRecordCreateRequestItem','Required parameter componentsSchemasRecordCreateRequestItem was null or undefined when calling createRecords.');
            }
            const localVarPath = `/studies/{studyKey}/records`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof componentsSchemasRecordCreateRequestItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(componentsSchemasRecordCreateRequestItem != null ? componentsSchemasRecordCreateRequestItem : {}) : (((componentsSchemasRecordCreateRequestItem:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List records (eCRF instances) in a study
         * @throws {RequiredError}
         */
        listRecords(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listRecords.');
            }
            const localVarPath = `/studies/{studyKey}/records`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (recordDataFilter !== undefined) {
                localVarQueryParameter['recordDataFilter'] = ((recordDataFilter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RecordsApiType = { 
    createRecords(studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options?: RequestOptions): Promise<RecordJobStatus>,

    listRecords(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options?: RequestOptions): Promise<RecordList>,
}

/**
 * RecordsApi - factory function to inject configuration 
 * @export
 */
export const RecordsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RecordsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Add new record or update subject/record data
         * @throws {RequiredError}
         */
        createRecords(studyKey: string, componentsSchemasRecordCreateRequestItem: Array<ComponentsSchemasRecordCreateRequestItem>, options?: RequestOptions = {}): Promise<RecordJobStatus> {
            const localVarFetchArgs = RecordsApiFetchParamCreator(configuration).createRecords(studyKey, componentsSchemasRecordCreateRequestItem, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List records (eCRF instances) in a study
         * @throws {RequiredError}
         */
        listRecords(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, recordDataFilter?: string, options?: RequestOptions = {}): Promise<RecordList> {
            const localVarFetchArgs = RecordsApiFetchParamCreator(configuration).listRecords(studyKey, page, size, sort, filter, recordDataFilter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SitesApi - fetch parameter creator
 * @export
 */
export const SitesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List sites for a study
         * @throws {RequiredError}
         */
        listSites(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listSites.');
            }
            const localVarPath = `/studies/{studyKey}/sites`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SitesApiType = { 
    listSites(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<SiteList>,
}

/**
 * SitesApi - factory function to inject configuration 
 * @export
 */
export const SitesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SitesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List sites for a study
         * @throws {RequiredError}
         */
        listSites(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<SiteList> {
            const localVarFetchArgs = SitesApiFetchParamCreator(configuration).listSites(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * StudiesApi - fetch parameter creator
 * @export
 */
export const StudiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List studies accessible by API key
         * @throws {RequiredError}
         */
        listStudies(page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/studies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type StudiesApiType = { 
    listStudies(page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<StudyList>,
}

/**
 * StudiesApi - factory function to inject configuration 
 * @export
 */
export const StudiesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): StudiesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List studies accessible by API key
         * @throws {RequiredError}
         */
        listStudies(page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<StudyList> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).listStudies(page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SubjectsApi - fetch parameter creator
 * @export
 */
export const SubjectsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List subjects in a study
         * @throws {RequiredError}
         */
        listSubjects(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listSubjects.');
            }
            const localVarPath = `/studies/{studyKey}/subjects`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SubjectsApiType = { 
    listSubjects(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<SubjectList>,
}

/**
 * SubjectsApi - factory function to inject configuration 
 * @export
 */
export const SubjectsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SubjectsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List subjects in a study
         * @throws {RequiredError}
         */
        listSubjects(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<SubjectList> {
            const localVarFetchArgs = SubjectsApiFetchParamCreator(configuration).listSubjects(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * VariablesApi - fetch parameter creator
 * @export
 */
export const VariablesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List variables (fields) in a study
         * @throws {RequiredError}
         */
        listVariables(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listVariables.');
            }
            const localVarPath = `/studies/{studyKey}/variables`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type VariablesApiType = { 
    listVariables(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<VariableList>,
}

/**
 * VariablesApi - factory function to inject configuration 
 * @export
 */
export const VariablesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): VariablesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List variables (fields) in a study
         * @throws {RequiredError}
         */
        listVariables(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<VariableList> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).listVariables(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * VisitsApi - fetch parameter creator
 * @export
 */
export const VisitsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List visits (subject visit instances) in a study
         * @throws {RequiredError}
         */
        listVisits(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'studyKey' is not null or undefined
            if (studyKey === null || studyKey === undefined) {
                throw new RequiredError('studyKey','Required parameter studyKey was null or undefined when calling listVisits.');
            }
            const localVarPath = `/studies/{studyKey}/visits`
                .replace(`{${"studyKey"}}`, encodeURIComponent(String(studyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication apiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication securityKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-imn-security-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-imn-security-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = ((size:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type VisitsApiType = { 
    listVisits(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions): Promise<VisitList>,
}

/**
 * VisitsApi - factory function to inject configuration 
 * @export
 */
export const VisitsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): VisitsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List visits (subject visit instances) in a study
         * @throws {RequiredError}
         */
        listVisits(studyKey: string, page?: number, size?: number, sort?: string, filter?: string, options?: RequestOptions = {}): Promise<VisitList> {
            const localVarFetchArgs = VisitsApiFetchParamCreator(configuration).listVisits(studyKey, page, size, sort, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    AdministrationApi: AdministrationApiType,

    CodingsApi: CodingsApiType,

    FormsApi: FormsApiType,

    IntervalsApi: IntervalsApiType,

    JobsApi: JobsApiType,

    QueriesApi: QueriesApiType,

    RecordRevisionsApi: RecordRevisionsApiType,

    RecordsApi: RecordsApiType,

    SitesApi: SitesApiType,

    StudiesApi: StudiesApiType,

    SubjectsApi: SubjectsApiType,

    VariablesApi: VariablesApiType,

    VisitsApi: VisitsApiType,
 }
