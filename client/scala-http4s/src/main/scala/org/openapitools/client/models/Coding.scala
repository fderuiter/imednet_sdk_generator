/** Mednet EDC API
  * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
  *
  * The version of the OpenAPI document: 1.3.6
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package org.openapitools.client.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}


/** 
  * @param studyKey Unique study key
  * @param siteName Name of the site associated with the coded data
  * @param siteId Site ID associated with the coded data
  * @param subjectId Subject ID associated with the coded data
  * @param subjectKey Subject key (display ID) associated with the coded data
  * @param formId Form ID where the coded data originates
  * @param formName Name of the form where the coded data originates
  * @param formKey Form key where the coded data originates
  * @param revision Revision number of the coding entry
  * @param recordId Record ID associated with the coded data
  * @param variable Variable name (field) that was coded
  * @param value Original value entered that required coding
  * @param codingId Mednet coding ID
  * @param code Standardized code assigned (e.g., dictionary term)
  * @param codedBy Name of the user who performed the coding
  * @param reason Reason for coding or any notes on changes
  * @param dictionaryName Name of the dictionary used (e.g., MedDRA)
  * @param dictionaryVersion Version of the dictionary used
  * @param dateCoded Date when the coding was performed
  */
case class Coding(
    studyKey: Option[String] = None,
    siteName: Option[String] = None,
    siteId: Option[Int] = None,
    subjectId: Option[Int] = None,
    subjectKey: Option[String] = None,
    formId: Option[Int] = None,
    formName: Option[String] = None,
    formKey: Option[String] = None,
    revision: Option[Int] = None,
    recordId: Option[Int] = None,
    variable: Option[String] = None,
    value: Option[String] = None,
    codingId: Option[Int] = None,
    code: Option[String] = None,
    codedBy: Option[String] = None,
    reason: Option[String] = None,
    dictionaryName: Option[String] = None,
    dictionaryVersion: Option[String] = None,
    dateCoded: Option[String] = None
)
  
object Coding {
  given encoderCoding: Encoder[Coding] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        t.studyKey.map(v => "studyKey" -> v.asJson),
        t.siteName.map(v => "siteName" -> v.asJson),
        t.siteId.map(v => "siteId" -> v.asJson),
        t.subjectId.map(v => "subjectId" -> v.asJson),
        t.subjectKey.map(v => "subjectKey" -> v.asJson),
        t.formId.map(v => "formId" -> v.asJson),
        t.formName.map(v => "formName" -> v.asJson),
        t.formKey.map(v => "formKey" -> v.asJson),
        t.revision.map(v => "revision" -> v.asJson),
        t.recordId.map(v => "recordId" -> v.asJson),
        t.variable.map(v => "variable" -> v.asJson),
        t.value.map(v => "value" -> v.asJson),
        t.codingId.map(v => "codingId" -> v.asJson),
        t.code.map(v => "code" -> v.asJson),
        t.codedBy.map(v => "codedBy" -> v.asJson),
        t.reason.map(v => "reason" -> v.asJson),
        t.dictionaryName.map(v => "dictionaryName" -> v.asJson),
        t.dictionaryVersion.map(v => "dictionaryVersion" -> v.asJson),
        t.dateCoded.map(v => "dateCoded" -> v.asJson)
      ).flatten
    }
  }
  given decoderCoding: Decoder[Coding] = Decoder.instance { c =>
    for {
      studyKey <- c.downField("studyKey").as[Option[String]]
      siteName <- c.downField("siteName").as[Option[String]]
      siteId <- c.downField("siteId").as[Option[Int]]
      subjectId <- c.downField("subjectId").as[Option[Int]]
      subjectKey <- c.downField("subjectKey").as[Option[String]]
      formId <- c.downField("formId").as[Option[Int]]
      formName <- c.downField("formName").as[Option[String]]
      formKey <- c.downField("formKey").as[Option[String]]
      revision <- c.downField("revision").as[Option[Int]]
      recordId <- c.downField("recordId").as[Option[Int]]
      variable <- c.downField("variable").as[Option[String]]
      value <- c.downField("value").as[Option[String]]
      codingId <- c.downField("codingId").as[Option[Int]]
      code <- c.downField("code").as[Option[String]]
      codedBy <- c.downField("codedBy").as[Option[String]]
      reason <- c.downField("reason").as[Option[String]]
      dictionaryName <- c.downField("dictionaryName").as[Option[String]]
      dictionaryVersion <- c.downField("dictionaryVersion").as[Option[String]]
      dateCoded <- c.downField("dateCoded").as[Option[String]]
    } yield Coding(
      studyKey = studyKey,
      siteName = siteName,
      siteId = siteId,
      subjectId = subjectId,
      subjectKey = subjectKey,
      formId = formId,
      formName = formName,
      formKey = formKey,
      revision = revision,
      recordId = recordId,
      variable = variable,
      value = value,
      codingId = codingId,
      code = code,
      codedBy = codedBy,
      reason = reason,
      dictionaryName = dictionaryName,
      dictionaryVersion = dictionaryVersion,
      dateCoded = dateCoded
    )
  }
}

