/**
 * Mednet EDC API
 * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
 *
 * The version of the OpenAPI document: 1.3.6
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIInterval.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIInterval::OAIInterval(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIInterval::OAIInterval() {
    this->initializeModel();
}

OAIInterval::~OAIInterval() {}

void OAIInterval::initializeModel() {

    m_study_key_isSet = false;
    m_study_key_isValid = false;

    m_interval_id_isSet = false;
    m_interval_id_isValid = false;

    m_interval_name_isSet = false;
    m_interval_name_isValid = false;

    m_interval_description_isSet = false;
    m_interval_description_isValid = false;

    m_interval_sequence_isSet = false;
    m_interval_sequence_isValid = false;

    m_interval_group_id_isSet = false;
    m_interval_group_id_isValid = false;

    m_interval_group_name_isSet = false;
    m_interval_group_name_isValid = false;

    m_timeline_isSet = false;
    m_timeline_isValid = false;

    m_defined_using_interval_isSet = false;
    m_defined_using_interval_isValid = false;

    m_window_calculation_form_isSet = false;
    m_window_calculation_form_isValid = false;

    m_window_calculation_date_isSet = false;
    m_window_calculation_date_isValid = false;

    m_actual_date_form_isSet = false;
    m_actual_date_form_isValid = false;

    m_actual_date_isSet = false;
    m_actual_date_isValid = false;

    m_due_date_will_be_in_isSet = false;
    m_due_date_will_be_in_isValid = false;

    m_negative_slack_isSet = false;
    m_negative_slack_isValid = false;

    m_positive_slack_isSet = false;
    m_positive_slack_isValid = false;

    m_epro_grace_period_isSet = false;
    m_epro_grace_period_isValid = false;

    m_forms_isSet = false;
    m_forms_isValid = false;

    m_disabled_isSet = false;
    m_disabled_isValid = false;

    m_date_created_isSet = false;
    m_date_created_isValid = false;

    m_date_modified_isSet = false;
    m_date_modified_isValid = false;
}

void OAIInterval::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIInterval::fromJsonObject(QJsonObject json) {

    m_study_key_isValid = ::OpenAPI::fromJsonValue(m_study_key, json[QString("studyKey")]);
    m_study_key_isSet = !json[QString("studyKey")].isNull() && m_study_key_isValid;

    m_interval_id_isValid = ::OpenAPI::fromJsonValue(m_interval_id, json[QString("intervalId")]);
    m_interval_id_isSet = !json[QString("intervalId")].isNull() && m_interval_id_isValid;

    m_interval_name_isValid = ::OpenAPI::fromJsonValue(m_interval_name, json[QString("intervalName")]);
    m_interval_name_isSet = !json[QString("intervalName")].isNull() && m_interval_name_isValid;

    m_interval_description_isValid = ::OpenAPI::fromJsonValue(m_interval_description, json[QString("intervalDescription")]);
    m_interval_description_isSet = !json[QString("intervalDescription")].isNull() && m_interval_description_isValid;

    m_interval_sequence_isValid = ::OpenAPI::fromJsonValue(m_interval_sequence, json[QString("intervalSequence")]);
    m_interval_sequence_isSet = !json[QString("intervalSequence")].isNull() && m_interval_sequence_isValid;

    m_interval_group_id_isValid = ::OpenAPI::fromJsonValue(m_interval_group_id, json[QString("intervalGroupId")]);
    m_interval_group_id_isSet = !json[QString("intervalGroupId")].isNull() && m_interval_group_id_isValid;

    m_interval_group_name_isValid = ::OpenAPI::fromJsonValue(m_interval_group_name, json[QString("intervalGroupName")]);
    m_interval_group_name_isSet = !json[QString("intervalGroupName")].isNull() && m_interval_group_name_isValid;

    m_timeline_isValid = ::OpenAPI::fromJsonValue(m_timeline, json[QString("timeline")]);
    m_timeline_isSet = !json[QString("timeline")].isNull() && m_timeline_isValid;

    m_defined_using_interval_isValid = ::OpenAPI::fromJsonValue(m_defined_using_interval, json[QString("definedUsingInterval")]);
    m_defined_using_interval_isSet = !json[QString("definedUsingInterval")].isNull() && m_defined_using_interval_isValid;

    m_window_calculation_form_isValid = ::OpenAPI::fromJsonValue(m_window_calculation_form, json[QString("windowCalculationForm")]);
    m_window_calculation_form_isSet = !json[QString("windowCalculationForm")].isNull() && m_window_calculation_form_isValid;

    m_window_calculation_date_isValid = ::OpenAPI::fromJsonValue(m_window_calculation_date, json[QString("windowCalculationDate")]);
    m_window_calculation_date_isSet = !json[QString("windowCalculationDate")].isNull() && m_window_calculation_date_isValid;

    m_actual_date_form_isValid = ::OpenAPI::fromJsonValue(m_actual_date_form, json[QString("actualDateForm")]);
    m_actual_date_form_isSet = !json[QString("actualDateForm")].isNull() && m_actual_date_form_isValid;

    m_actual_date_isValid = ::OpenAPI::fromJsonValue(m_actual_date, json[QString("actualDate")]);
    m_actual_date_isSet = !json[QString("actualDate")].isNull() && m_actual_date_isValid;

    m_due_date_will_be_in_isValid = ::OpenAPI::fromJsonValue(m_due_date_will_be_in, json[QString("dueDateWillBeIn")]);
    m_due_date_will_be_in_isSet = !json[QString("dueDateWillBeIn")].isNull() && m_due_date_will_be_in_isValid;

    m_negative_slack_isValid = ::OpenAPI::fromJsonValue(m_negative_slack, json[QString("negativeSlack")]);
    m_negative_slack_isSet = !json[QString("negativeSlack")].isNull() && m_negative_slack_isValid;

    m_positive_slack_isValid = ::OpenAPI::fromJsonValue(m_positive_slack, json[QString("positiveSlack")]);
    m_positive_slack_isSet = !json[QString("positiveSlack")].isNull() && m_positive_slack_isValid;

    m_epro_grace_period_isValid = ::OpenAPI::fromJsonValue(m_epro_grace_period, json[QString("eproGracePeriod")]);
    m_epro_grace_period_isSet = !json[QString("eproGracePeriod")].isNull() && m_epro_grace_period_isValid;

    m_forms_isValid = ::OpenAPI::fromJsonValue(m_forms, json[QString("forms")]);
    m_forms_isSet = !json[QString("forms")].isNull() && m_forms_isValid;

    m_disabled_isValid = ::OpenAPI::fromJsonValue(m_disabled, json[QString("disabled")]);
    m_disabled_isSet = !json[QString("disabled")].isNull() && m_disabled_isValid;

    m_date_created_isValid = ::OpenAPI::fromJsonValue(m_date_created, json[QString("dateCreated")]);
    m_date_created_isSet = !json[QString("dateCreated")].isNull() && m_date_created_isValid;

    m_date_modified_isValid = ::OpenAPI::fromJsonValue(m_date_modified, json[QString("dateModified")]);
    m_date_modified_isSet = !json[QString("dateModified")].isNull() && m_date_modified_isValid;
}

QString OAIInterval::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIInterval::asJsonObject() const {
    QJsonObject obj;
    if (m_study_key_isSet) {
        obj.insert(QString("studyKey"), ::OpenAPI::toJsonValue(m_study_key));
    }
    if (m_interval_id_isSet) {
        obj.insert(QString("intervalId"), ::OpenAPI::toJsonValue(m_interval_id));
    }
    if (m_interval_name_isSet) {
        obj.insert(QString("intervalName"), ::OpenAPI::toJsonValue(m_interval_name));
    }
    if (m_interval_description_isSet) {
        obj.insert(QString("intervalDescription"), ::OpenAPI::toJsonValue(m_interval_description));
    }
    if (m_interval_sequence_isSet) {
        obj.insert(QString("intervalSequence"), ::OpenAPI::toJsonValue(m_interval_sequence));
    }
    if (m_interval_group_id_isSet) {
        obj.insert(QString("intervalGroupId"), ::OpenAPI::toJsonValue(m_interval_group_id));
    }
    if (m_interval_group_name_isSet) {
        obj.insert(QString("intervalGroupName"), ::OpenAPI::toJsonValue(m_interval_group_name));
    }
    if (m_timeline_isSet) {
        obj.insert(QString("timeline"), ::OpenAPI::toJsonValue(m_timeline));
    }
    if (m_defined_using_interval_isSet) {
        obj.insert(QString("definedUsingInterval"), ::OpenAPI::toJsonValue(m_defined_using_interval));
    }
    if (m_window_calculation_form_isSet) {
        obj.insert(QString("windowCalculationForm"), ::OpenAPI::toJsonValue(m_window_calculation_form));
    }
    if (m_window_calculation_date_isSet) {
        obj.insert(QString("windowCalculationDate"), ::OpenAPI::toJsonValue(m_window_calculation_date));
    }
    if (m_actual_date_form_isSet) {
        obj.insert(QString("actualDateForm"), ::OpenAPI::toJsonValue(m_actual_date_form));
    }
    if (m_actual_date_isSet) {
        obj.insert(QString("actualDate"), ::OpenAPI::toJsonValue(m_actual_date));
    }
    if (m_due_date_will_be_in_isSet) {
        obj.insert(QString("dueDateWillBeIn"), ::OpenAPI::toJsonValue(m_due_date_will_be_in));
    }
    if (m_negative_slack_isSet) {
        obj.insert(QString("negativeSlack"), ::OpenAPI::toJsonValue(m_negative_slack));
    }
    if (m_positive_slack_isSet) {
        obj.insert(QString("positiveSlack"), ::OpenAPI::toJsonValue(m_positive_slack));
    }
    if (m_epro_grace_period_isSet) {
        obj.insert(QString("eproGracePeriod"), ::OpenAPI::toJsonValue(m_epro_grace_period));
    }
    if (m_forms.size() > 0) {
        obj.insert(QString("forms"), ::OpenAPI::toJsonValue(m_forms));
    }
    if (m_disabled_isSet) {
        obj.insert(QString("disabled"), ::OpenAPI::toJsonValue(m_disabled));
    }
    if (m_date_created_isSet) {
        obj.insert(QString("dateCreated"), ::OpenAPI::toJsonValue(m_date_created));
    }
    if (m_date_modified_isSet) {
        obj.insert(QString("dateModified"), ::OpenAPI::toJsonValue(m_date_modified));
    }
    return obj;
}

QString OAIInterval::getStudyKey() const {
    return m_study_key;
}
void OAIInterval::setStudyKey(const QString &study_key) {
    m_study_key = study_key;
    m_study_key_isSet = true;
}

bool OAIInterval::is_study_key_Set() const{
    return m_study_key_isSet;
}

bool OAIInterval::is_study_key_Valid() const{
    return m_study_key_isValid;
}

qint32 OAIInterval::getIntervalId() const {
    return m_interval_id;
}
void OAIInterval::setIntervalId(const qint32 &interval_id) {
    m_interval_id = interval_id;
    m_interval_id_isSet = true;
}

bool OAIInterval::is_interval_id_Set() const{
    return m_interval_id_isSet;
}

bool OAIInterval::is_interval_id_Valid() const{
    return m_interval_id_isValid;
}

QString OAIInterval::getIntervalName() const {
    return m_interval_name;
}
void OAIInterval::setIntervalName(const QString &interval_name) {
    m_interval_name = interval_name;
    m_interval_name_isSet = true;
}

bool OAIInterval::is_interval_name_Set() const{
    return m_interval_name_isSet;
}

bool OAIInterval::is_interval_name_Valid() const{
    return m_interval_name_isValid;
}

QString OAIInterval::getIntervalDescription() const {
    return m_interval_description;
}
void OAIInterval::setIntervalDescription(const QString &interval_description) {
    m_interval_description = interval_description;
    m_interval_description_isSet = true;
}

bool OAIInterval::is_interval_description_Set() const{
    return m_interval_description_isSet;
}

bool OAIInterval::is_interval_description_Valid() const{
    return m_interval_description_isValid;
}

qint32 OAIInterval::getIntervalSequence() const {
    return m_interval_sequence;
}
void OAIInterval::setIntervalSequence(const qint32 &interval_sequence) {
    m_interval_sequence = interval_sequence;
    m_interval_sequence_isSet = true;
}

bool OAIInterval::is_interval_sequence_Set() const{
    return m_interval_sequence_isSet;
}

bool OAIInterval::is_interval_sequence_Valid() const{
    return m_interval_sequence_isValid;
}

qint32 OAIInterval::getIntervalGroupId() const {
    return m_interval_group_id;
}
void OAIInterval::setIntervalGroupId(const qint32 &interval_group_id) {
    m_interval_group_id = interval_group_id;
    m_interval_group_id_isSet = true;
}

bool OAIInterval::is_interval_group_id_Set() const{
    return m_interval_group_id_isSet;
}

bool OAIInterval::is_interval_group_id_Valid() const{
    return m_interval_group_id_isValid;
}

QString OAIInterval::getIntervalGroupName() const {
    return m_interval_group_name;
}
void OAIInterval::setIntervalGroupName(const QString &interval_group_name) {
    m_interval_group_name = interval_group_name;
    m_interval_group_name_isSet = true;
}

bool OAIInterval::is_interval_group_name_Set() const{
    return m_interval_group_name_isSet;
}

bool OAIInterval::is_interval_group_name_Valid() const{
    return m_interval_group_name_isValid;
}

QString OAIInterval::getTimeline() const {
    return m_timeline;
}
void OAIInterval::setTimeline(const QString &timeline) {
    m_timeline = timeline;
    m_timeline_isSet = true;
}

bool OAIInterval::is_timeline_Set() const{
    return m_timeline_isSet;
}

bool OAIInterval::is_timeline_Valid() const{
    return m_timeline_isValid;
}

QString OAIInterval::getDefinedUsingInterval() const {
    return m_defined_using_interval;
}
void OAIInterval::setDefinedUsingInterval(const QString &defined_using_interval) {
    m_defined_using_interval = defined_using_interval;
    m_defined_using_interval_isSet = true;
}

bool OAIInterval::is_defined_using_interval_Set() const{
    return m_defined_using_interval_isSet;
}

bool OAIInterval::is_defined_using_interval_Valid() const{
    return m_defined_using_interval_isValid;
}

QString OAIInterval::getWindowCalculationForm() const {
    return m_window_calculation_form;
}
void OAIInterval::setWindowCalculationForm(const QString &window_calculation_form) {
    m_window_calculation_form = window_calculation_form;
    m_window_calculation_form_isSet = true;
}

bool OAIInterval::is_window_calculation_form_Set() const{
    return m_window_calculation_form_isSet;
}

bool OAIInterval::is_window_calculation_form_Valid() const{
    return m_window_calculation_form_isValid;
}

QString OAIInterval::getWindowCalculationDate() const {
    return m_window_calculation_date;
}
void OAIInterval::setWindowCalculationDate(const QString &window_calculation_date) {
    m_window_calculation_date = window_calculation_date;
    m_window_calculation_date_isSet = true;
}

bool OAIInterval::is_window_calculation_date_Set() const{
    return m_window_calculation_date_isSet;
}

bool OAIInterval::is_window_calculation_date_Valid() const{
    return m_window_calculation_date_isValid;
}

QString OAIInterval::getActualDateForm() const {
    return m_actual_date_form;
}
void OAIInterval::setActualDateForm(const QString &actual_date_form) {
    m_actual_date_form = actual_date_form;
    m_actual_date_form_isSet = true;
}

bool OAIInterval::is_actual_date_form_Set() const{
    return m_actual_date_form_isSet;
}

bool OAIInterval::is_actual_date_form_Valid() const{
    return m_actual_date_form_isValid;
}

QString OAIInterval::getActualDate() const {
    return m_actual_date;
}
void OAIInterval::setActualDate(const QString &actual_date) {
    m_actual_date = actual_date;
    m_actual_date_isSet = true;
}

bool OAIInterval::is_actual_date_Set() const{
    return m_actual_date_isSet;
}

bool OAIInterval::is_actual_date_Valid() const{
    return m_actual_date_isValid;
}

qint32 OAIInterval::getDueDateWillBeIn() const {
    return m_due_date_will_be_in;
}
void OAIInterval::setDueDateWillBeIn(const qint32 &due_date_will_be_in) {
    m_due_date_will_be_in = due_date_will_be_in;
    m_due_date_will_be_in_isSet = true;
}

bool OAIInterval::is_due_date_will_be_in_Set() const{
    return m_due_date_will_be_in_isSet;
}

bool OAIInterval::is_due_date_will_be_in_Valid() const{
    return m_due_date_will_be_in_isValid;
}

qint32 OAIInterval::getNegativeSlack() const {
    return m_negative_slack;
}
void OAIInterval::setNegativeSlack(const qint32 &negative_slack) {
    m_negative_slack = negative_slack;
    m_negative_slack_isSet = true;
}

bool OAIInterval::is_negative_slack_Set() const{
    return m_negative_slack_isSet;
}

bool OAIInterval::is_negative_slack_Valid() const{
    return m_negative_slack_isValid;
}

qint32 OAIInterval::getPositiveSlack() const {
    return m_positive_slack;
}
void OAIInterval::setPositiveSlack(const qint32 &positive_slack) {
    m_positive_slack = positive_slack;
    m_positive_slack_isSet = true;
}

bool OAIInterval::is_positive_slack_Set() const{
    return m_positive_slack_isSet;
}

bool OAIInterval::is_positive_slack_Valid() const{
    return m_positive_slack_isValid;
}

qint32 OAIInterval::getEproGracePeriod() const {
    return m_epro_grace_period;
}
void OAIInterval::setEproGracePeriod(const qint32 &epro_grace_period) {
    m_epro_grace_period = epro_grace_period;
    m_epro_grace_period_isSet = true;
}

bool OAIInterval::is_epro_grace_period_Set() const{
    return m_epro_grace_period_isSet;
}

bool OAIInterval::is_epro_grace_period_Valid() const{
    return m_epro_grace_period_isValid;
}

QList<OAIComponents_schemas_Interval_forms_item> OAIInterval::getForms() const {
    return m_forms;
}
void OAIInterval::setForms(const QList<OAIComponents_schemas_Interval_forms_item> &forms) {
    m_forms = forms;
    m_forms_isSet = true;
}

bool OAIInterval::is_forms_Set() const{
    return m_forms_isSet;
}

bool OAIInterval::is_forms_Valid() const{
    return m_forms_isValid;
}

bool OAIInterval::isDisabled() const {
    return m_disabled;
}
void OAIInterval::setDisabled(const bool &disabled) {
    m_disabled = disabled;
    m_disabled_isSet = true;
}

bool OAIInterval::is_disabled_Set() const{
    return m_disabled_isSet;
}

bool OAIInterval::is_disabled_Valid() const{
    return m_disabled_isValid;
}

QString OAIInterval::getDateCreated() const {
    return m_date_created;
}
void OAIInterval::setDateCreated(const QString &date_created) {
    m_date_created = date_created;
    m_date_created_isSet = true;
}

bool OAIInterval::is_date_created_Set() const{
    return m_date_created_isSet;
}

bool OAIInterval::is_date_created_Valid() const{
    return m_date_created_isValid;
}

QString OAIInterval::getDateModified() const {
    return m_date_modified;
}
void OAIInterval::setDateModified(const QString &date_modified) {
    m_date_modified = date_modified;
    m_date_modified_isSet = true;
}

bool OAIInterval::is_date_modified_Set() const{
    return m_date_modified_isSet;
}

bool OAIInterval::is_date_modified_Valid() const{
    return m_date_modified_isValid;
}

bool OAIInterval::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_study_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_sequence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_group_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_group_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeline_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_defined_using_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_window_calculation_form_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_window_calculation_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_actual_date_form_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_actual_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_due_date_will_be_in_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_negative_slack_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_positive_slack_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_epro_grace_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_forms.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_disabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_created_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_modified_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIInterval::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
